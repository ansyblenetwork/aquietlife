---
title: "Options collateral analysis via the Robinhood API"
---

<p>A Robinhood API applet to analyze your options collateral. Login is persistent via local storage.</p>




<div style="margin-top:30px">
	<div id="monitorPage" style="text-align:center; display:none; border-bottom:solid; margin-bottom:20px">	
		<button onclick="toggleSound(this);" id="soundButton" class="active">Sound On</button>
		<button onclick="toggleNotifications(this);" id="notificationButton">Notifications Off</button>
		<button onclick="toggleAlerts(this);">Auto-Refresh Off</button>
		<div style="padding-top:20px">Near or in the money:
		<ul style="overflow:auto; max-height:30vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="itm"></ul>
		</div>	
		<div style="width:max-content; margin:auto">
			<input id="defaultLower" style="width:60px" onblur="if (!this.value) this.value = 0; defaultLower = val(this);" type="text" autocomplete="off" value="2" placeholder="Margin..."> % 
			<input onkeyup="if (event.keyCode == 27) this.value = '';
					else if (event.keyCode == 13) {
						event.preventDefault(); 
						submitTicker();
					}"
			id="tickerInput" onfocus="this.select()" type="text" style="margin-left:10px; margin-right:10px" autocomplete="off" placeholder="Monitor stock..."> 
			<input id="defaultUpper" style="width:60px" onblur="if (!this.value) this.value = 0; defaultUpper = val(this)" type="text" autocomplete="off" value="2" placeholder="Margin..."> % 
		</div>
		<ul style="overflow:auto; max-height:50vh; list-style-type:none; padding-left:0px" id="stocklist"></ul>	
	</div>
	
	<div id="profilePage" style="text-align:center; display:none; border-bottom:solid; margin-bottom:20px">		
	
		<div id="controlPanel" style="text-align:left; position:fixed; bottom:10px; left:0px; max-width:920px;">
		<audio id="audiodown" src="{{ "case-closed-531.mp3" | relative_url }}" autostart="false"></audio>
		<audio id="audio" src="{{ "that-was-quick.mp3" | relative_url }}" autostart="false"></audio>
		<button onclick="toggleAuto(this);" id="autoButton" class="active">Order-Chaining On</button>
		<div style="float:right">
			<span id="msg" onclick="getData(); getOptions();" style="cursor:pointer; border-radius:5px; background-color:white; padding: 5px 10px;"></span>
			<button id="optionButton" onclick="getData(); getOptions();">Analyze Positions</button>
			<button id="optionButton" onclick="logout();">Log Out</button>
		</div>
		</div>
		
		<div style="font-weight:bold; padding:10px">Total value: <span id="accountValue">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cash available: <span id="cash"></span></div>	
		<div style="padding-top:20px">Orders:
		<ul style="overflow:auto; max-height:30vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="orders"></ul>
		</div>
		<div style="padding-top:20px; width:50%; display:inline-block; vertical-align:top">Incomplete spreads:
		<ul style="overflow:auto; max-height:30vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="singles"></ul>
		</div>		
		<div style="padding-top:20px; width:49%; display:inline-block; vertical-align:top">Incomplete condors:
		<ul style="overflow:auto; max-height:30vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="unpaired"></ul>
		</div>
		<div style="padding-top:20px">
		<ul style="overflow:auto; max-height:50vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="recList"></ul>
		</div>
		<div style="padding-top:20px">Spread buybacks:
		<ul style="overflow:auto; max-height:30vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="release"></ul>
		</div>		
		<div style="padding-top:20px">Condor buybacks:
		<ul style="overflow:auto; max-height:30vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="condorRelease"></ul>
		</div>				
		<div style="padding-top:20px; padding-bottom:20px;">Partial condor buybacks:
		<ul style="overflow:auto; max-height:30vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="ncRelease"></ul>
		</div>		
	</div>
	
	
	<div id="explorationPage" style="text-align:center; display:none; border-bottom:solid">	
		<div style="width:max-content; margin:auto; margin-bottom:10px">
		<input onkeyup="if (event.keyCode == 27) this.value = '';
				else if (event.keyCode == 13) {
					event.preventDefault(); 
					optionsChain();
				}"
		id="optionsInput" onfocus="this.select()" type="text" style="margin:10px;" autocomplete="off" placeholder="Options chain..."><button onclick="optionsChain()">Fetch</button>
		</div>
		<ul style="overflow:auto; max-height:50vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="optionslist"></ul>
	</div>
	
	<div id="loginPage" style="display:none;">	
	
	<form id="loginForm" onsubmit="submitLoginForm(); return false;">	
		Username:<br>
		<input id="loginUsername" type="text" autocapitalize="off" autocomplete="off">
		<br><br>
		Password:<br>
		<input id="loginPassword" type="password" autocomplete="off">		
		<br><br>
		<div style="text-align:left; padding-left:10px">
			<button id="smallloginbut" type="submit">Log In</button>
			<button type="button" style="margin-right:10px; margin-bottom:10px;" onclick="D('loginForm').reset()">Cancel</button>
    		</div>
	</form> 
	
	<form id="MFAForm" onsubmit="submitMFAForm(); return false;" style="padding-top:20px; display:none">	
		MFA:<br>
		<input id="loginMFA" type="password" autocomplete="off">		
		<br><br>
		<div style="text-align:left; padding-left:10px">
			<button id="smallloginbut" type="submit">Submit</button>
			<button type="button" style="margin-right:10px; margin-bottom:10px;" onclick="D('MFAForm').reset()">Cancel</button>
    		</div>
	</form> 
		
	</div>
</div>

<script>/////////////////////////////////////////////////////////

// authentication variables
var currentID;
var form = {};
var authData = {};
var authHeader = {};
var accountURL = "";
	
// the main list of options data from the account
var optionsBySymbol = {};
	
// map from Robinhood option URL to contract type
var urlMap = {};
var dteMap = {};
	
// monitoring variables
var currentOption = "";
var tickerList = [];
var volumes = {};
var prices = {};
var defaultUpper = 2;
var defaultLower = 2;
let yahootimer;
var d = new Date();
D('msg').textContent = d.toLocaleTimeString();
setInput(D('defaultLower')); 
setInput(D('defaultUpper'));
	
// recommendation variables	
var fixedInterestRate = 10;
var optionsQuotes = {};	
var incompleteCondorList = {};
	
if (Notification.permission === "granted") activate(D('notificationButton'), "Notifications On");
	
if (!(screen.width <= 550 || screen.height <= 550)) {				
	window.addEventListener("resize", resizeControls);
	D("accountPanel").addEventListener("click", resizeControls);
	resizeControls();
	function resizeControls() { 
		// 50 for the left padding in the content; 40 for the right padding
		var w = D('accountPanel').offsetWidth + 50;
		D("controlPanel").style.paddingLeft = `${w}px`;
		D("controlPanel").style.width = `calc(100% - ${w}px - 40px)`;
	}  
}
	
if (typeof(Storage) !== "undefined") {
	authHeader = {'Authorization': localStorage.getItem("authString") };
	if (localStorage.getItem("authString")) {
		showDiv('profilePage');
		showDiv('monitorPage');
	}
	else showDiv('loginPage');
} 	
	
function D(string) { return document.getElementById(string); }	
function DE(id) {
	if (typeof id === 'string' || id instanceof String) return D(id);
	else return id;	
}	
function showDiv(id) { DE(id).style.display = 'block';}	
function hide(id) { DE(id).style.display = 'none';}
	

	
function optionsChain() {	
	if (D('optionsInput').value.toUpperCase()) updateOptions(true);
}
							       
function updateOptions(newOption) {	
	let query = currentOption;
	if (newOption) query = D('optionsInput').value.toUpperCase();
		
	fetch("https://ansyble.herokuapp.com/cors/", 
		{cache:'no-cache', headers: {'Target-Ticker': query }}).then(function(response) {
		return response.json();
	}).then(function(data) {
		optionsQuotes[query] = data;
		if (currentOption == query) {
			for (let i = 0; i < D('optionslist').children.length; i++) {
				if (Math.sqrt(parseFloat(D('optionslist').children[i].children[0].title)) * (1 + parseFloat(optionsQuotes[query].volatility.split('% ')[0])) * 2 < 										parseFloat(D('optionslist').children[i].children[1].title)) {
				D('optionslist').children[i].children[1].style.backgroundColor = "#ddf";
				D('optionslist').children[i].children[2].style.backgroundColor = "#ddf";
				}
			}
		}
	});
	
	let d = new Date(Date.now() + 1000*60*60*24*12).toISOString();								       
	fetch("https://api.tdameritrade.com/v1/marketdata/chains?apikey=T1V8GYUYK3GKC7HG3L23O9XBJ5OH1C4F&symbol=" 
		+ query + "&range=OTM&toDate=" + d).then(function(response) {
		return response.json();
	}).then(function(data) {
		console.log(data);
		if (data.status == "SUCCESS") {	
			currentOption = query;	
			clearDOM(D('optionslist'));
			
			
			let rhfetch;
			
			for (let contractDate in data.callExpDateMap) {
						   
			/////////////////////// CALLS //////////////////////////////////
				
				let defData = {strike:0, premium:0, contract:""};
				let altData = {strike:0, premium:0, contract:""};
				setDefLeg(defData, altData, data.callExpDateMap[contractDate]);
	
				let calldefleg = buildli(defData.contract, data);
				D('optionslist').appendChild(calldefleg);
				let calldefleg2 = buildli(altData.contract, data);
				D('optionslist').appendChild(calldefleg2);
				let referenceli = calldefleg2;
				
				if (!rhfetch) rhfetch = rhOption(query, contractDate.substring(0, 10), 'call', altData.strike);				
				let altDupe = {strike:altData.strike, premium:altData.premium, contract:altData.contract};
				
				rhfetch.then(function() {
				let callOrders = setBuyOrders(data.callExpDateMap[contractDate], altDupe, contractDate, query);
				createBuyOrder(calldefleg2, 'call', 'buy', 0, callOrders, query);
				});
				       
				let callArray = [];
				for (let contractStrike in data.callExpDateMap[contractDate]) {
					let contract = data.callExpDateMap[contractDate][contractStrike][0];
					if (evalContract(contract, data, altData)) callArray.unshift(contract);
				}	       
	
				let maxReturn = 0;
				callArray.forEach(function(contract) {				
					if (maxReturn < returnRate(contract, altData)) {
						maxReturn = returnRate(contract, altData);
						let contractli = buildli(contract, data, calldefleg2, altData);
						D('optionslist').appendChild(contractli);
						
						rhfetch.then(function() {
						let sellCallOrders = setSellOrders(data.callExpDateMap[contractDate], contract, contractDate, query);
						createBuyOrder(contractli, 'call', 'sell', 0, sellCallOrders, query);
						});
					}
				});
	
			/////////////////////// MIDDLE //////////////////////////////////
	
				referenceli = make('li');
				referenceli.style.textAlign = "center";
				referenceli.style.fontWeight = "bold";
				addCol("$" + round(data.underlyingPrice), "75px", referenceli);
				addCol(data.symbol + " " + defData.contract.daysToExpiration + " DTE", "675px", referenceli);
				D('optionslist').appendChild(referenceli);	
	
			/////////////////////// PUTS //////////////////////////////////
	
				defData = {strike:0, premium:0, contract:""};
				altData = {strike:0, premium:0, contract:""};
				setDefLeg(defData, altData, data.putExpDateMap[contractDate]);
				
				let putdefleg2 = buildli(altData.contract, data);
				D('optionslist').appendChild(putdefleg2);
				let putdefleg = buildli(defData.contract, data);
				D('optionslist').appendChild(putdefleg);
				putdefleg.style.marginBottom = "30px";
				
				rhfetch.then(function() {
				let putOrders = setBuyOrders(data.putExpDateMap[contractDate], altData, contractDate, query);
				createBuyOrder(putdefleg2, 'put', 'buy', 0, putOrders, query);
				});
	
				let putArray = [];
				for (let contractStrike in data.putExpDateMap[contractDate]) {
					let contract = data.putExpDateMap[contractDate][contractStrike][0];
					if (evalContract(contract, data, altData)) putArray.push(contract);
				}
	
				maxReturn = 0;
				putArray.forEach(function(contract) {				
					if (maxReturn < returnRate(contract, altData)) {
						maxReturn = returnRate(contract, altData);
						let contractli = buildli(contract, data, putdefleg2, altData);
						D('optionslist').insertBefore(contractli, referenceli.nextElementSibling);
						
						rhfetch.then(function() {
						let sellPutOrders = setSellOrders(data.putExpDateMap[contractDate], contract, contractDate, query);
						createBuyOrder(contractli, 'put', 'sell', 0, sellPutOrders, query);
						});
					}
				});
			}
		} else D('msg').textContent = "No options data found.";				       	       
	});								       
}
	
	
///// Recommenation for condors //////////////////////////////////////////////////////

function rhOption(symbol, expiration, type, strike) {
	return fetchData('https://api.robinhood.com/instruments/?symbol=' + symbol, 'GET').then(function(data) {
		let optionForm = {
			'chain_id': data.results[0].tradable_chain_id,
			'expiration_dates': expiration,
			'strike_price': strike,
			'type': type,
			'state': 'active'
		};
		let urlstring = '?' + Object.keys(optionForm).map(key => key + '=' + optionForm[key]).join('&');
	return fetchData('https://api.robinhood.com/options/instruments/' + urlstring, 'GET').then(function(data) {		
		if (!optionsBySymbol[symbol])
			optionsBySymbol[symbol] = {tick: parseFloat(data.results[0].min_ticks.below_tick), shortCall:[], shortPut:[], defCall:[], defPut:[]};
				
		return data;
	});	
	});
}

function createBuyOrder(li, type, side, count, orders, symbol) {
clickable(li.firstChild);
li.firstChild.onclick = function() {
	let confMsg = "Buy this defensive " + type + "?";
	if (side == "sell") confMsg = "Open this " + type + "?";
if (confirm(confMsg)) {	
	D('orders').scrollIntoView({behavior: "smooth"});				
	function orderProceed(li, count) {
		rhOption(symbol,orders[count].expiration,type,orders[count].strike).then(function(data) {
			fetchData('https://api.robinhood.com/options/orders/', 
				  'POST', 
				  { headers:authHeader, json:makeOrderForm('open', side, data.results[0].url, orders[count].premium/100, optionsBySymbol[symbol].tick) }).then(function(data) {
				let orderli = makeOrderli(symbol, {type: type, expire:orders[count].expiration, strike:inDollars(orders[count].strike) }, data, li);
				if (orderli) {							
					orderli.lastElementChild.onclick = function() {		
						confMsg = "Cancel buying this defensive " + type + "?";
						if (side == "sell") confMsg = "Cancel opening this " + type + "?";
					if (confirm(confMsg)) {
						fetchData(data.cancel_url, 'POST', { headers:authHeader }).then(function(data) {
							if (stylizeCancel(orderli, data, li) && count + 1 < orders.length) createBuyOrder(orderli, type, side, count + 1, orders);
						});
					}
					}
					if (active(D('autoButton'))) {
						setTimeout(function() {
						fetchData(data.cancel_url, 'POST', { headers:authHeader }).then(function(data) {
							if (stylizeCancel(orderli, data, li) && count + 1 < orders.length) orderProceed(orderli, count + 1);
						});
						}, 1000);
					}
				}
			});
		});
	}

	orderProceed(li, count);
}
}
}
	
	
	
function setBuyOrders(data, altData, contractDate, symbol) {
	let orders = [];
	let ask = inDollars(altData.premium);
	let bid = inDollars(altData.contract.bid);
	let tick = 1;
	if (optionsBySymbol[symbol]) tick = inDollars(optionsBySymbol[symbol].tick);
	let strike = altData.strike;

	for (let i = bid + tick; i <= ask; i += tick) {
		for (let contractStrike in data) {
			let contract = data[contractStrike][0];
			if ((contract.putCall == "CALL" && contract.strikePrice <= strike) || (contract.putCall == "PUT" && contract.strikePrice >= strike)) {
				if (inDollars(contract.bid) < i) orders.push({expiration:contractDate.substring(0, 10), strike: contract.strikePrice,  premium: i });
			}
		}
	}

	orders.sort(function(y, x) {return rate(x) - rate(y);});
	function rate(order) {
		let cost = order.premium - bid;
		let collateral = strike - order.strike;
		if (collateral < 0) collateral = 0 - collateral;
		if (collateral == 0) collateral = 0.0001;
		return collateral / cost;
	}
	console.log(symbol + " orders: ");
	console.log(altData);
	console.log(data);
	console.log(orders);
	if (orders.length > 4) {
		let sparseOrders = [];
		for (let i = 0; i < 4; i++) {
			sparseOrders.push(orders[Math.round(i*orders.length/4)]);
		}
		if (Math.round(3*orders.length/4) != (orders.length - 1)) sparseOrders.push(orders[orders.length - 1]);
		return sparseOrders;
	}
	return orders;
}		
	
function setSellOrders(data, mainContract, contractDate, symbol) {
	let orders = [];
	let ask = inDollars(mainContract.ask);
	let bid = inDollars(mainContract.bid);
	let tick = 1;
	if (optionsBySymbol[symbol]) tick = inDollars(optionsBySymbol[symbol].tick);
	let strike = mainContract.strikePrice;

	for (let i = bid; i <= ask - tick; i += tick) {
		for (let contractStrike in data) {
			let contract = data[contractStrike][0];
			if ((contract.putCall == "CALL" && contract.strikePrice >= strike) || (contract.putCall == "PUT" && contract.strikePrice <= strike)) {
				if (inDollars(contract.ask) > i) orders.push({expiration:contractDate.substring(0, 10), strike: contract.strikePrice,  premium: i });
			}
		}
	}

	orders.sort(function(y, x) {return rate(x) - rate(y);});
	function rate(order) {
		let cost = ask - order.premium;
		let collateral = strike - order.strike;
		if (collateral < 0) collateral = 0 - collateral;
		if (collateral == 0) collateral = 0.0001;
		return collateral / cost;
	}
	if (orders.length > 4) {
		let sparseOrders = [];
		for (let i = 0; i < 4; i++) {
			sparseOrders.push(orders[Math.round(i*orders.length/4)]);
		}
		if (Math.round(3*orders.length/4) != (orders.length - 1)) sparseOrders.push(orders[orders.length - 1]);
		return sparseOrders;
	}
	return orders;
}	
	
function generateRec(symbol, data) {	
	for (let contractDate in data.callExpDateMap) {
		
		let candidateObj = {};	
		
	/////////////////////// CALLS //////////////////////////////////

		let defData = {strike:0, premium:0, contract:""};
		let altData = {strike:0, premium:0, contract:""};
		setDefLeg(defData, altData, data.callExpDateMap[contractDate]);
		let callOrders = setBuyOrders(data.callExpDateMap[contractDate], altData, contractDate, symbol);
	
		let callArray = [];
		for (let contractStrike in data.callExpDateMap[contractDate]) {
			let contract = data.callExpDateMap[contractDate][contractStrike][0];
			if (evalContract(contract, data, altData) && contractAboveVolatility(contract, data)) callArray.unshift(contract);
		}	       

		let maxReturn = 0;
		let candidate;
		callArray.forEach(function(contract) {
			if (maxReturn < returnRate(contract, altData)) {
				candidate = contract;
				maxReturn = returnRate(contract, altData);
			}
		});
		
		if (candidate) candidateObj.call = {contract:candidate, altData:altData};

	/////////////////////// PUTS //////////////////////////////////

		defData = {strike:0, premium:0, contract:""};
		altData = {strike:0, premium:0, contract:""};
		setDefLeg(defData, altData, data.putExpDateMap[contractDate]);
		let putOrders = setBuyOrders(data.putExpDateMap[contractDate], altData, contractDate, symbol);
	
		let putArray = [];
		for (let contractStrike in data.putExpDateMap[contractDate]) {
			let contract = data.putExpDateMap[contractDate][contractStrike][0];
			if (evalContract(contract, data, altData) && contractAboveVolatility(contract, data)) putArray.push(contract);
		}

		maxReturn = 0;
		candidate = null;
		putArray.forEach(function(contract) {
			if (maxReturn < returnRate(contract, altData)) {
				candidate = contract;
				maxReturn = returnRate(contract, altData);
			}
		});	
		if (candidate) candidateObj.put = {contract:candidate, altData:altData};
		
		// add to DOM //////////////////////////////////////////////////
		if (incompleteCondorList[symbol][contractDate.substring(0, 10)]) {
		let bag = make('li');	
		let callrate = 0;
		let putrate = 0;
		////////////// build the table /////////////////////////////////				

			if (candidateObj.call && incompleteCondorList[symbol][contractDate.substring(0, 10)].call) {
				let calldefleg2 = buildli(candidateObj.call.altData.contract, data);
				bag.appendChild(calldefleg2);
				let calloffleg = buildli(candidateObj.call.contract, data, calldefleg2, candidateObj.call.altData);
				bag.appendChild(calloffleg);
				callrate = returnRate(candidateObj.call.contract, candidateObj.call.altData);
				
				let sellCallOrders = setSellOrders(data.callExpDateMap[contractDate], candidateObj.call.contract, contractDate, symbol);
				createBuyOrder(calldefleg2, 'call', 'buy', 0, callOrders, symbol);
				createBuyOrder(calloffleg, 'call', 'sell', 0, sellCallOrders, symbol);
			}

		/////////////////////// MIDDLE //////////////////////////////////

			let referenceli = make('li');
			referenceli.style.textAlign = "center";
			referenceli.style.fontWeight = "bold";
			addCol("$" + round(data.underlyingPrice), "75px", referenceli);
			addCol(data.symbol + " " + defData.contract.daysToExpiration + " DTE", "675px", referenceli);
			bag.appendChild(referenceli);	

		/////////////////////// PUTS //////////////////////////////////

			if (candidateObj.put && incompleteCondorList[symbol][contractDate.substring(0, 10)].put) {
				let putdefleg2 = buildli(candidateObj.put.altData.contract, data);
				bag.appendChild(putdefleg2);
				putdefleg2.style.marginBottom = "30px";
				let putoffleg = buildli(candidateObj.put.contract, data, putdefleg2, candidateObj.put.altData);
				bag.insertBefore(putoffleg, referenceli.nextElementSibling);
				putrate = returnRate(candidateObj.put.contract, candidateObj.put.altData);
				
				let sellPutOrders = setSellOrders(data.putExpDateMap[contractDate], candidateObj.put.contract, contractDate, symbol);
				createBuyOrder(putdefleg2, 'put', 'buy', 0, putOrders, symbol);
				createBuyOrder(putoffleg, 'put', 'sell', 0, sellPutOrders, symbol);
			} else referenceli.style.marginBottom = "30px";		

		bag.title = 0 - putrate - callrate;
		addOrdered(bag, D('recList'));	
		}
	}
}	
	
function setDefLeg(defData, altData, data, contractDate, symbol) {      
	for (let contractStrike in data) {	
		let contract = data[contractStrike][0];

		let dstrike = defData.strike;
		let newstrike = contract.strikePrice;
		if (contract.putCall == "PUT") {
			dstrike = -dstrike; newstrike = -newstrike;
		}
		if (contract.ask > 0) {	
			if (defData.premium == 0 || contract.ask < defData.premium || (contract.ask == defData.premium && newstrike < dstrike)) {
				defData.strike = contract.strikePrice;
				defData.premium = contract.ask;
				defData.contract = contract;
			}
		}
	}
	
	let candData = {strike:defData.strike, premium:defData.premium, contract:defData.contract};
	
	while (true) {	
		altData.strike = candData.strike;
		altData.premium = candData.premium;
		altData.contract = candData.contract;
		
		candData = {strike:0, premium:0, contract:""};
		let currentContract;
		for (let contractStrike in data) {
			let contract = data[contractStrike][0];

			let cstrike = candData.strike;
			let astrike = altData.strike;
			let newstrike = contract.strikePrice;
			if (contract.putCall == "PUT") {
				cstrike = -cstrike; astrike = -astrike; newstrike = -newstrike;
			}
			if (contract.ask > altData.premium && newstrike < astrike
				&& (candData.premium == 0 || contract.ask < candData.premium || (contract.ask == candData.premium && newstrike < cstrike))) {
				candData.strike = contract.strikePrice;
				candData.premium = contract.ask;
				candData.contract = contract;
				currentContract = contract;
			}
		}
		
		if (!currentContract || altData.strike == candData.strike || interestRate(currentContract, altData) > fixedInterestRate) break;
	}
}	
	

function buildli(contract, data, defleg, altData) {
	let li = make('li');
	li.style.textAlign = "center";		
	let col = addCol("$" + contract.strikePrice, "75px", li);
	let weeksToExp = (1 + (contract.expirationDate-Date.now())/(1000*60*60*24))/7;
	col.title = weeksToExp;
	if (contract.putCall == "CALL") col = addCol("+" + margin(contract, data) + "%", "75px", li);
	else col = addCol("-" + margin(contract, data) + "%", "75px", li);

	let collat = "x";
	if (altData) {
		if (contract.putCall == "CALL") collat = 100*(altData.strike - contract.strikePrice);
		else collat = 100*(contract.strikePrice - altData.strike);		
		let col2 = addCol( "$" + collat, "75px", li);
		col.title = margin(contract, data);
		if (contractAboveVolatility(contract, data))  {	
			col.style.backgroundColor = "#ddf";
			col2.style.backgroundColor = "#ddf";
		}

	} else addCol("x", "75px", li);

	let colstring = Math.round(returnRate(contract, altData)) + "%";
	col = addCol(colstring, "100px", li);

	let rate = 295 - 2*Math.round(returnRate(contract, altData));
	if (rate < 0) col.style.backgroundColor = "#00ffff";
	else if (rate < 16) col.style.backgroundColor = "#0" + rate.toString(16) + "ffff";
	else col.style.backgroundColor = "#" + rate.toString(16) + "ffff";

	let premdiff = "x.xx";
	if (altData) premdiff = (contract.bid - altData.premium).toFixed(2);
	col = addCol(premdiff, "50px", li);		   
	if (rate < 0) col.style.backgroundColor = "#00ffff";
	else if (rate < 16) col.style.backgroundColor = "#0" + rate.toString(16) + "ffff";						   
	else col.style.backgroundColor = "#" + rate.toString(16) + "ffff";

	col = addCol(contract.bid.toFixed(2) + ' x ' + contract.bidSize, "100px", li);	
	if (rate < 0) col.style.backgroundColor = "#00ffff";
	else if (rate < 16) col.style.backgroundColor = "#0" + rate.toString(16) + "ffff";						   
	else col.style.backgroundColor = "#" + rate.toString(16) + "ffff";

	col = addCol(contract.ask.toFixed(2) + ' x ' + contract.askSize, "100px", li);

	if (contract.askSize > 5*contract.bidSize && contract.ask < contract.bid + 0.06) col.style.backgroundColor = "#ddf";

	addCol(contract.last.toFixed(2), "50px", li);							
	let lastTrade = "x";
	if (contract.tradeTimeInLong) lastTrade = Math.round((Date.now() - contract.tradeTimeInLong)/60000);			       
	addCol(lastTrade + "m", "75px", li);
	addCol(contract.totalVolume, "50px", li);
	li.classList.add("libold");

	if (defleg) {
		li.onmouseenter = function() { defleg.style.fontWeight = "bold"; }
		li.onmouseleave = function() { defleg.style.fontWeight = ""; }
	}
	else {						
		rate = 255 - 100*16*contract.ask;								       
		if (rate < 0) li.children[6].style.backgroundColor = "#00ffff";
		else if (rate < 16)  li.children[6].style.backgroundColor = "#0" + rate.toString(16) + "ffff";
		else  li.children[6].style.backgroundColor = "#" + rate.toString(16) + "ffff";
	}
						   
	return li;
}	
	
function contractAboveVolatility(contract, data) {
	let weeksToExp = (1 + (contract.expirationDate-Date.now())/(1000*60*60*24))/7;
	return (optionsQuotes[data.symbol] && Math.sqrt(weeksToExp) * (1 + parseFloat(optionsQuotes[data.symbol].volatility.split('% ')[0])) * 2 < margin(contract, data));
}

function interestRate(contract, defData) {
	if (contract.ask <= defData.premium) return 0;
	if (contract.putCall == "CALL")	return 100*(contract.ask - defData.premium)*365*1000*60*60*24
			/((defData.strike - contract.strikePrice)*(1000*60*60*66 + contract.expirationDate-Date.now()));
	else return 100*(contract.ask - defData.premium)*365*1000*60*60*24
			/((contract.strikePrice - defData.strike)*(1000*60*60*66 + contract.expirationDate-Date.now()));
}
	
function returnRate(contract, defData) {
	if (!defData) return 0;
	if (contract.bid <= defData.premium) return 0;
	if (contract.putCall == "CALL")	return 100*(contract.bid - defData.premium)*365*1000*60*60*24
			/((defData.strike - contract.strikePrice)*(1000*60*60*66 + contract.expirationDate-Date.now()));
	else return 100*(contract.bid - defData.premium)*365*1000*60*60*24
			/((contract.strikePrice - defData.strike)*(1000*60*60*66 + contract.expirationDate-Date.now()));
}

function margin(contract, data) {
	let returnMargin;
	if (contract.putCall == "CALL") returnMargin = 100*(contract.strikePrice - data.underlyingPrice)/data.underlyingPrice;
	else returnMargin = 100*(data.underlyingPrice - contract.strikePrice)/data.underlyingPrice;
	if (returnMargin < 2) return round(returnMargin, true);
	else return Math.round(returnMargin);
}

function evalContract(contract, data, altData) {
	return (returnRate(contract, altData) > 19);
}
	
	
///// logging in //////////////////////////////////////////////////////
	
function logout() {
	D('cash').textContent = "";
	D('accountValue').textContent = "\xa0\xa0\xa0\xa0\xa0";
	wipeDOM();
	
	currentID = "";
	form = {};
	authData = {};
	authHeader = {};	
	optionsBySymbol = {};
	urlMap = {};
	tickerList = [];
	incompleteCondorList = {};
	
	clearDOM(D('orders'));
	clearDOM(D('itm'));
	clearDOM(D('stocklist'));
	hide('explorationPage');
	hide('profilePage');
	hide('monitorPage');
	showDiv('loginPage');
	D('loginPage').style.display = "block";
	
	// if (typeof(Storage) !== "undefined") localStorage.setItem("authString", "");
}	
	
function clearDOM(myNode) {
	while (myNode.firstChild) { myNode.removeChild(myNode.lastChild); }
}
	
function wipeDOM() {	
	//clearDOM(D('orders'));
	
	clearDOM(D('recList'));
	clearDOM(D('singles'));
	clearDOM(D('unpaired'));
	
	clearDOM(D('release'));
	clearDOM(D('condorRelease'));
	clearDOM(D('ncRelease'));
	
	// clearDOM(D('itm'));
	// clearDOM(D('stocklist'));
}
	
function fetchData(url, method, data) {
	let stringified = "";
	if (data) stringified = JSON.stringify(data);
	return fetch("https://sandboxansyble.herokuapp.com/cors/", 
		{cache:'no-cache', headers: {method: method, url: url, 'json-data': stringified }}).then(function(response) {
		return response.json();
	});
}
	
function generate_device_token() {
    let rands = [];
    for (let i = 0; i < 16; i++) {
        rands.push((Math.round(4294967296.0 * Math.random()) >> ((3 & i) << 3)) & 255);
    }

    let hexa = [];
    for (let i = 0; i < 256; i++) {	
	let myhex = (i + 256).toString(16).substring(1);
        hexa.push(myhex);
    }

    let id = "";
    for (let i = 0; i < 16; i++) {
        id += hexa[rands[i]];
        if ((i == 3) || (i == 5) || (i == 7) || (i == 9)) id += "-";
    }
   return id;
}

function submitLoginForm() {
	let mytoken = generate_device_token();
	form = {
		'client_id': 'c82SH0WZOsabOXGP2sxqcj34FxkvfnWRZBKlBjFS',
		'expires_in': 86400,
		'grant_type': 'password',
		'password': D('loginPassword').value,
		'username': D('loginUsername').value,
		'scope': 'internal',
		'challenge_type': "sms",
		'device_token': mytoken
	};

	fetchData("https://api.robinhood.com/oauth2/token/", 'POST', {form:form}).then(function(data){
		show('MFAForm');
		if (data.challenge) currentID = data.challenge.id;
	});
}
  
function submitMFAForm() {
	fetchData('https://api.robinhood.com/challenge/' + currentID + '/respond/', 'POST', { form:{ 'response': D('loginMFA').value }}).then(function(data){
		fetchData("https://api.robinhood.com/oauth2/token/", 'POST', {form:form, headers:{'X-ROBINHOOD-CHALLENGE-RESPONSE-ID':currentID}}).then(function(data){
			hide('MFAForm');
			showDiv('explorationPage');
			showDiv('profilePage');
			showDiv('monitorPage');
			hide('loginPage');
			authData = data;
			authHeader = {'Authorization':data.token_type + " " + data.access_token};
	
			if (typeof(Storage) !== "undefined") localStorage.setItem("authString", data.token_type + " " + data.access_token);
		});
	});
}
	

	
///// Positions analysis code //////////////////////////////////////////////////////
	
function makeOrderli(symbol, contract, data, origin) {
	console.log("The response to the order: ");
	console.log(data);				
	let orderli;
	if (data.detail) {
		orderli = makeli(symbol, contract);
		addCol(data.detail, "calc(100% - 350px)", orderli);
		D('orders').appendChild(orderli);
		return false;
	}
	else {
		if (origin) {
			origin.style.color = "#aaa";
			declickable(origin.firstChild);
		}
		orderli = makeli(symbol, contract);
		let col = addCol(data.legs[0].side, "75px", orderli);
		col.style.backgroundColor = "#dff";
		col = addCol(data.legs[0].position_effect, "75px", orderli);
		col.style.backgroundColor = "#dff";
		col = addCol(parseFloat(data.price).toFixed(2), "75px", orderli);
		col.style.backgroundColor = "#dff";
		let processedCol = addCol(parseFloat(data.processed_quantity), "75px", orderli);
		let msg = addCol("Pending...", "calc(100% - 650px)", orderli);
		clickable(msg);	
		
		if (!orderStatus(data, msg, processedCol, orderli)) return false;

		orderli.onclick = function() {
			fetchData('https://api.robinhood.com/options/orders/' + data.id, 'GET', { headers:authHeader}).then(function(data) {
				console.log("Checking for update on status for order:");
				console.log(data);
				orderStatus(data, msg, processedCol, orderli);
				orderli.style.backgroundColor = "#dff";
				setTimeout(function() {	orderli.style.backgroundColor = ""; }, 300);
			});
		}		
		D('orders').appendChild(orderli);
		return orderli;
	}
}
	
function orderStatus(data, msg, processedCol, orderli) {
	if (parseFloat(data.processed_quantity) > 0) {
		processedCol.textContent = "$" + parseFloat(data.processed_premium).toFixed(2);
		msg.textContent = "Partially completed...";
		if (Math.round(parseFloat(data.pending_quantity)) == 0) {
			msg.textContent = "Completed!";
			if (Math.round(parseFloat(data.canceled_quantity)) > 0) msg.textContent = "Remainder cancelled!";
			orderli.onclick = "";
			declickable(msg);
			return false;
		}
	} else if (!data.cancel_url) {
		msg.textContent = "Cancelled!";	
		orderli.onclick = "";
		declickable(msg);	
		if (processedCol.textContent == '0') processedCol.textContent = 'X';
		return false;
	}
	return true;
}		

function stylizeCancel(orderli, data, origin) {
	console.log("The response to the cancel request: ");
	console.log(data);
	if (data.detail) {
		orderli.lastElementChild.textContent = data.detail;
		orderli.click();
		return false;
	} else if (data.processed_quantity === undefined) {
		orderli.lastElementChild.textContent = "Status unknown.";
		orderli.click();
		return false;
	} else return !orderStatus(data, orderli.lastElementChild, orderli.lastElementChild.previousElementSibling, orderli);
}
	
function makeOrderForm(effect, side, url, price, tick) {
	let dbcd = "credit";
	if (side == "buy") dbcd = "debit";
	if (price <= 0) price = tick;
	let json = {
		'account': accountURL,
		'direction': dbcd,
		'time_in_force': 'gfd',
		'legs': [{'position_effect': effect, 'side': side, 'ratio_quantity': 1, 'option': url }],
		'type': 'limit',
		'trigger': 'immediate',
		'price': roundTwo(price),
		'quantity': 1,
		'override_day_trade_checks': false,
		'override_dtbp_checks': false,
		'ref_id': generate_device_token()
	}	
	console.log(json);
	return json;
}
	
function getData() {	
	fetchData("https://api.robinhood.com/portfolios/", 'GET', {headers:authHeader}).then(function(data) {
		accountURL = data.results[0].account;
		showDiv('explorationPage');
		
		let growth = data.results[0].equity - data.results[0].equity_previous_close;		
		if (growth > 0) D("accountValue").style.color = "#1a8";
		else if (growth < 0) {
			D("accountValue").style.color = "#F00";
			growth = 0 - growth;
		}
		
		D('accountValue').textContent = "$" + parseFloat(data.results[0].equity).toFixed(2) + " ($" + parseFloat(growth).toFixed(2) +")";
		D('cash').textContent = "$" + parseFloat(data.results[0].withdrawable_amount).toFixed(2);
		
		console.log("Portfolios");
		console.log(data);
	});
}	

	
	
window.addEventListener('keydown', function(evt) {
	if (evt.keyCode == 85 && evt.ctrlKey && evt.shiftKey) {
		evt.preventDefault();
		getData();
		getOptions();
	}
});
	
function getOptions() {	
D('optionButton').disabled = true;
fetchData('https://api.robinhood.com/options/orders/', 'GET', { headers:authHeader }).then(function(data) {
	console.log("All open orders:");
	console.log(data);
	clearDOM(D('orders'));
	
	for (let i = 0; i < data.results.length; i++) {	
		let symbol = data.results[i].chain_symbol;
		if (data.results[i].cancel_url) {			
			function createGenericOrder(optionData, origin) {
				let orderData = data.results[i];
				let orderli = makeOrderli(symbol, {type: optionData.type, expire:optionData.expiration_date, strike:inDollars(parseFloat(optionData.strike_price))}, orderData, origin);
				if (orderli) {
				orderli.lastElementChild.onclick = function() {
					let myMsg = "Leave this collateral frozen?";
					if (orderData.legs[0].side == "buy" && orderData.legs[0].position_effect == "open") 
						myMsg = "Give up on opening this defensive leg?";
					if (orderData.legs[0].side == "sell" && orderData.legs[0].position_effect == "open") 
						myMsg = "Give up on earning this premium?";
					if (orderData.legs[0].side == "sell" && orderData.legs[0].position_effect == "close") 
						myMsg = "Keep this defensive leg, and perhaps put it to use?";

					if (confirm(myMsg)) {
					fetchData(orderData.cancel_url, 'POST', { headers:authHeader }).then(function(cancelData) {
						if (stylizeCancel(orderli, cancelData, origin)) {
							clickable(orderli.firstChild);
							orderli.firstChild.onclick = function() {
								let confirmMsg = "Re-order, selling for less?";
								if (orderData.legs[0].side == "buy") confirmMsg = "Re-order, buying for more?";
								if (confirm(confirmMsg)) {
									let price = parseFloat(orderData.price) + parseFloat(optionData.min_ticks.below_tick);
									if (orderData.legs[0].side == 'sell') price = parseFloat(orderData.price) - parseFloat(optionData.min_ticks.below_tick);

									fetchData('https://api.robinhood.com/options/orders/', 
										  'POST', 
										  { headers:authHeader,	json:makeOrderForm(orderData.legs[0].position_effect, orderData.legs[0].side, orderData.legs[0].option, price, parseFloat(optionData.min_ticks.below_tick)) }).then(function(newdata) {
										createGenericOrder(optionData, orderli);
									});
								}
							}
						}
					});
					}
				}
				}
			}
			if (urlMap[symbol]) createGenericOrder(urlMap[symbol]);
			else fetchData(data.results[i].legs[0].option, 'GET').then(function(getData) {
				urlMap[data.results[i].legs[0].option] = getData;
				createGenericOrder(getData);
			});
		}
	}
});
	
fetchData("https://api.robinhood.com/options/positions/?nonzero=True", 'GET', { headers:authHeader }).then(function(data) {
	console.log(data);
	let optionsPositions = data.results;
	wipeDOM();
	let promises = [];
	optionsBySymbol = {};
	taskBySymbol = {};
	incompleteCondorList = {};
	for (let i = 0; i < optionsPositions.length; i++) {			
		if (!optionsBySymbol[optionsPositions[i].chain_symbol]) {
			optionsBySymbol[optionsPositions[i].chain_symbol] = {shortCall:[], shortPut:[], defCall:[], defPut:[]};
			taskBySymbol[optionsPositions[i].chain_symbol] = [];
		}
		
		function handleOptionPosition(optionData) {
			optionsBySymbol[optionData.chain_symbol].tick = parseFloat(optionData.min_ticks.below_tick);
			
			let quantity = parseInt(optionsPositions[i].quantity);
			for (let j = 0; j < quantity; j++) {
				let dat = {url:optionData.url, type: optionData.type, expire:optionData.expiration_date, strike:inDollars(parseFloat(optionData.strike_price))};
				if (optionsPositions[i].type == "short") {
					if (optionData.type == "call") optionsBySymbol[optionData.chain_symbol].shortCall.push(dat);
					else optionsBySymbol[optionData.chain_symbol].shortPut.push(dat);
				}
				if (optionsPositions[i].type == "long") {
					if (optionData.type == "call") optionsBySymbol[optionData.chain_symbol].defCall.push(dat);
					else optionsBySymbol[optionData.chain_symbol].defPut.push(dat);
				}
			}
		}
		if (urlMap[optionsPositions[i].option]) handleOptionPosition(urlMap[optionsPositions[i].option]);
		else {
			let task = fetchData(optionsPositions[i].option, 'GET').then(function(getData) {
				urlMap[optionsPositions[i].option] = getData;
				handleOptionPosition(getData);
			});
			promises.push(task);
			taskBySymbol[optionsPositions[i].chain_symbol].push(task);
		}
	}
	
	let queryString = "";
	for (let symbol in taskBySymbol) {
		let tick = optionsBySymbol[symbol].tick;
		queryString += symbol + ",";
		Promise.all(taskBySymbol[symbol]).then(function() {
			optionsBySymbol[symbol].shortPut.sort(function(b, a) {
				if (a.expire > b.expire) return 1;
				else if (a.expire < b.expire) return -1;
				else if (a.strike > b.strike) return 1;
				else if (a.strike < b.strike) return -1;
				else return 0;					
			});
			optionsBySymbol[symbol].defPut.sort(function(b, a) { 
				if (a.expire < b.expire) return 1;
				else if (a.expire > b.expire) return -1;
				else if (a.strike > b.strike) return 1;
				else if (a.strike < b.strike) return -1;
				else return 0;					
			});

			let append = optionsBySymbol[symbol].shortCall.length - optionsBySymbol[symbol].defCall;
			for (let i = 0; i < append; i++) {
				 optionsBySymbol[symbol].defCall.push({expire:"never", strike:0});
			}

			optionsBySymbol[symbol].shortCall.sort(function(b, a) {
				if (a.expire > b.expire) return 1;
				else if (a.expire < b.expire) return -1;
				else if (a.strike < b.strike) return 1;
				else if (a.strike > b.strike) return -1;
				else return 0;					
			});
			optionsBySymbol[symbol].defCall.sort(function(b, a) {
				if (a.expire < b.expire) return 1;
				else if (a.expire > b.expire) return -1;
				else if (a.strike < b.strike) return 1;
				else if (a.strike > b.strike) return -1;
				else return 0;					
			});

			for (let i = 0; i < optionsBySymbol[symbol].shortPut.length; i++) {
				findPutPair(symbol, null, optionsBySymbol[symbol].shortPut[i]);
			}
			for (let i = 0; i < optionsBySymbol[symbol].shortCall.length; i++) {
				findCallPair(symbol, null, optionsBySymbol[symbol].shortCall[i]);
			}
			let totalCollateral = condor(symbol, true);
			let totalPutCollateral = noCondorPuts(symbol);
			let totalCallCollateral = noCondorCalls(symbol);

			for (let i = 0; i < optionsBySymbol[symbol].shortPut.length; i++) {
				let me = optionsBySymbol[symbol].shortPut[i];
				let myStrike = me.strike;
				let friend = me.friend;
				if (friend) {
					clearOption(friend);
					clearOption(me);
					me.strike = 0;

					findPutPair(symbol, friend);
					me.closeRelease = totalCollateral - condor(symbol);
					me.ncRelease = totalPutCollateral - noCondorPuts(symbol);

					me.strike = myStrike;
					findPutPair(symbol, null, me);
				} else {
					me.closeRelease = myStrike;
					me.ncRelease = myStrike;
				}
			}

			for (let i = 0; i < optionsBySymbol[symbol].shortCall.length; i++) {
				let me = optionsBySymbol[symbol].shortCall[i];
				let myExpire = me.expire;
				let friend = me.friend;

				clearOption(friend);
				clearOption(me);
				me.expire = "neverplus";
				me.collateral = 0;

				findCallPair(symbol, friend);			
				me.closeRelease = totalCollateral - condor(symbol);
				me.ncRelease = totalCallCollateral - noCondorCalls(symbol);

				me.condorPair = [];
				for (let j = 0; j < optionsBySymbol[symbol].shortPut.length; j++) {
					let mypair = optionsBySymbol[symbol].shortPut[j];
					if (myExpire == mypair.expire) {
						let myPairStrike = mypair.strike;
						let pairFriend = mypair.friend;
						if (pairFriend) {
							clearOption(pairFriend);
							clearOption(mypair);
							mypair.strike = 0;

							findPutPair(symbol, pairFriend);
							me.condorPair.push({condorPair:mypair, condorRelease:totalCollateral - condor(symbol)});

							mypair.strike = myPairStrike;
							findPutPair(symbol, null, mypair);
						}
					}
				}

				me.expire = myExpire;
				delete me.collateral;
				findCallPair(symbol, null, me);
			}
			
			let d = new Date(Date.now() + 1000*60*60*24*21).toISOString();	
			fetch("https://api.tdameritrade.com/v1/marketdata/chains?apikey=T1V8GYUYK3GKC7HG3L23O9XBJ5OH1C4F&symbol=" 
				+ symbol + "&range=OTM&toDate=" + d).then(function(response) {
				return response.json();
			}).then(function(data) {
			console.log(data);
			if (data.status == "SUCCESS") {
				let dateMapData = {};
				for (let contractDate in data.putExpDateMap) {
					let expiration = contractDate.substring(0, 10);
					dateMapData[expiration] = contractDate;
					for (let mystrike in data.putExpDateMap[contractDate]) {
						dteMap[expiration] = data.putExpDateMap[contractDate][mystrike][0].daysToExpiration;
						break;
					}
				}					
				function dateMap(expiration) { return dateMapData[expiration]; }
				function strikeMap(strike) { return (strike/100).toFixed(1).toString();	}
					
				function createSingleOrder(li, contract, orderPrem) {
				clickable(li.firstChild);
				li.firstChild.onclick = function() {
				if (confirm("Sell this orphan defensive leg, for a dollar or two?")) {
					D('orders').scrollIntoView({behavior: "smooth"});
					function singleOrderProceed(li, contract, orderPrem) {
						fetchData('https://api.robinhood.com/options/orders/', 
							  'POST', 
							  { headers:authHeader, json:makeOrderForm('close','sell', contract.url, orderPrem, tick) }).then(function(data) {
							let orderli = makeOrderli(symbol, contract, data, li);						
							if (orderli) {
								orderli.lastElementChild.onclick = function() {										
								if (confirm("Keep this orphan defensive leg, and perhaps put it to use?")) {
									fetchData(data.cancel_url, 'POST', { headers:authHeader }).then(function(data) {
										if (stylizeCancel(orderli, data, li)) createSingleOrder(orderli, contract, orderPrem - tick);
									});
								}
								}								
								if (active(D('autoButton')) && inDollars((orderPrem - tick)) > 0) {									
									setTimeout(function() {
									fetchData(data.cancel_url, 'POST', { headers:authHeader }).then(function(data) {
										if (stylizeCancel(orderli, data, li)) singleOrderProceed(orderli, contract, orderPrem - tick);
									});
									}, 1000);
								}
							}
						});
					}
					singleOrderProceed(li, contract, orderPrem);
				}
				}
				}
				
				function checkOrphanDef(contract, type) {					
					if (!contract.friend) {
						let li = makeli(symbol, contract);
						let prem = 0;
						let vol = 0;
						let strikeList = data.putExpDateMap[dateMap(contract.expire)];
						if (type == "call") strikeList = data.callExpDateMap[dateMap(contract.expire)];
						if (strikeList) {
							if (!(strikeList[strikeMap(contract.strike)])) prem = -1; // this is in the money
							else {
								prem = strikeList[strikeMap(contract.strike)][0].bid;
								vol =  strikeList[strikeMap(contract.strike)][0].totalVolume;
							}
						}
						let col = addCol(prem.toFixed(2), "75px", li);
						if (prem > 0) col.style.backgroundColor = "#dff";
						col = addCol(vol, "75px", li);
						if (vol > 15) col.style.backgroundColor = "#dff";
						D('singles').appendChild(li);
						
						if (prem > 0 || vol > 15) {
							if (!incompleteCondorList[symbol]) incompleteCondorList[symbol] = {};
							if (!incompleteCondorList[symbol][contract.expire]) incompleteCondorList[symbol][contract.expire] = {};
							if (type == "call") incompleteCondorList[symbol][contract.expire].call = true;
							else incompleteCondorList[symbol][contract.expire].put = true;
						}
						
						createSingleOrder(li, contract, prem + tick);
					}
				}
				optionsBySymbol[symbol].defPut.forEach(function(contract) {
					checkOrphanDef(contract, "put");
				});
				optionsBySymbol[symbol].defCall.forEach(function(contract) {
					checkOrphanDef(contract, "call");
				});
				
				function rateCalc(premium, collateral, time) { return 100*100*premium*365*1000*60*60*24/(collateral*(1000*60*60*66 + time - Date.now())); }
				
				let bestPut = null;
				let ncPut = null;
				optionsBySymbol[symbol].shortPut.forEach(function(contract) {
				if (data.putExpDateMap[dateMap(contract.expire)] && data.putExpDateMap[dateMap(contract.expire)][strikeMap(contract.strike)]) {
					let tdaContract = data.putExpDateMap[dateMap(contract.expire)][strikeMap(contract.strike)][0];
					contract.premium = tdaContract.ask;
					if (tdaContract.last < contract.premium) contract.premium = tdaContract.last;
					contract.rate = rateCalc(contract.premium, contract.closeRelease, tdaContract.expirationDate);
					if ((!bestPut && contract.closeRelease > 0) || (bestPut && contract.rate < bestPut.rate)) bestPut = contract;

					contract.ncRate = rateCalc(contract.premium, contract.ncRelease, tdaContract.expirationDate);
					if ((!ncPut && contract.ncRelease > 0) || (ncPut && contract.ncRate < ncPut.ncRate)) ncPut = contract;
				}
				});

				let bestCondor = {call:null, put:null, rate:Infinity};
				let bestCall = null;
				let ncCall = null;
				optionsBySymbol[symbol].shortCall.forEach(function(contract) {
				if (data.callExpDateMap[dateMap(contract.expire)] && data.callExpDateMap[dateMap(contract.expire)][strikeMap(contract.strike)]) {					
					let tdaContract = data.callExpDateMap[dateMap(contract.expire)][strikeMap(contract.strike)][0];
					contract.premium = tdaContract.ask;
					if (tdaContract.ask < contract.premium)	contract.premium = tdaContract.last;
					contract.rate = rateCalc(contract.premium, contract.closeRelease, tdaContract.expirationDate);
					if ((!bestCall && contract.closeRelease > 0) || (bestCall && contract.rate < bestCall.rate)) bestCall = contract;

					contract.ncRate = rateCalc(contract.premium, contract.ncRelease, tdaContract.expirationDate);
					if ((!ncCall && contract.ncRelease > 0) || (ncCall && contract.ncRate < ncCall.ncRate)) ncCall = contract;

					contract.condorPair.forEach(function(pair) {
						let contract2 = pair.condorPair;
						contract2.premium = data.putExpDateMap[dateMap(contract.expire)][strikeMap(contract2.strike)][0].ask;
						if (data.putExpDateMap[dateMap(contract.expire)][strikeMap(contract2.strike)][0].last < contract2.premium)
							contract2.premium = data.putExpDateMap[dateMap(contract.expire)][strikeMap(contract2.strike)][0].last;
						let condorRate = rateCalc(contract2.premium + contract.premium, pair.condorRelease, tdaContract.expirationDate);
						if (condorRate < bestCondor.rate) 
							bestCondor = {call:contract, put:contract2, premium:(contract2.premium + contract.premium), rate:condorRate, release:pair.condorRelease};
					});
				}
				});

				function addColCost(li, elt, rate, collateral) {
					li.title = rate;
					let col = addCol("$" + collateral, "75px", li);
					col.style.backgroundColor = "#dff";
					col = addCol(elt.premium.toFixed(2), "75px", li);
					col.style.backgroundColor = "#dff";
					col = addCol(Math.round(rate) + "%", "75px", li);
					col.style.backgroundColor = "#dff";
				}
				
				function createOrder(li, contract, orderPrem) {
				clickable(li.firstChild);
				li.firstChild.onclick = function() {
				if (confirm("Close this spread to free up collateral?")) {	
					D('orders').scrollIntoView({behavior: "smooth"});				
					function orderProceed(li, contract, orderPrem, count) {
					orderPrem -= (inDollars(orderPrem) % inDollars(tick))/100;
					fetchData('https://api.robinhood.com/options/orders/', 
						  'POST', 
						  { headers:authHeader, json:makeOrderForm('close','buy', contract.url, orderPrem, tick) }).then(function(data) {
						let orderli = makeOrderli(symbol, contract, data, li);
						if (orderli) {							
							orderli.lastElementChild.onclick = function() {										
							if (confirm("Leave this collateral frozen?")) {
								fetchData(data.cancel_url, 'POST', { headers:authHeader }).then(function(data) {
									if (stylizeCancel(orderli, data, li)) createOrder(orderli, contract, orderPrem + tick);
								});
							}
							}
							
							if (active(D('autoButton')) && count < 3) {
								setTimeout(function() {
								fetchData(data.cancel_url, 'POST', { headers:authHeader }).then(function(data) {
									if (stylizeCancel(orderli, data, li)) orderProceed(orderli, contract, orderPrem + tick, count + 1);
								});
								}, 1000);
							}
						}
					});
					}
					orderProceed(li, contract, orderPrem, 1);
				}
				}
				}

				if (ncPut) {						
					let li = makeli(symbol, ncPut);
					addColCost(li, ncPut, ncPut.ncRate, ncPut.ncRelease);
					addOrdered(li, D('ncRelease'));
					createOrder(li, ncPut, ncPut.premium - tick);
				}
				if (bestPut) {						
					let li = makeli(symbol, bestPut);
					addColCost(li, bestPut, bestPut.rate, bestPut.closeRelease);
					addOrdered(li, D('release'));
					createOrder(li, bestPut, bestPut.premium - tick);
				}
				if (ncCall) {					
					let li = makeli(symbol, ncCall);
					addColCost(li, ncCall, ncCall.ncRate, ncCall.ncRelease);
					addOrdered(li, D('ncRelease'));
					createOrder(li, ncCall, ncCall.premium - tick);
				}
				if (bestCall) {					
					let li = makeli(symbol, bestCall);
					addColCost(li, bestCall, bestCall.rate, bestCall.closeRelease);
					addOrdered(li, D('release'));
					createOrder(li, bestCall, bestCall.premium - tick);
				}
				if (bestCondor.release) {
					let li = makeli(symbol, bestCondor.call);

					addCol(bestCondor.put.type, "50px", li);
					addCol("$" + bestCondor.put.strike/100, "75px", li);

					addColCost(li, bestCondor, bestCondor.rate, bestCondor.release);					
					addOrdered(li, D('condorRelease'));
				}
				
				fetch("https://ansyble.herokuapp.com/cors/", 
					{cache:'no-cache', headers: {'Target-Ticker': symbol }}).then(function(response) {
					return response.json();
				}).then(function(quotedata) {
					optionsQuotes[symbol] = quotedata;
					generateRec(symbol, data);
				})
			} 			       	       
			});
		});
	}
	
	Promise.all(promises).then(function() {		
		// query yahoo for ITM contracts
		D('optionButton').disabled = false;
		fetchData('https://query1.finance.yahoo.com/v7/finance/quote?symbols=' + queryString, 'GET').then(function(data) {
		let monitorQuery = [];
		let monitorMargin = [];
		clearDOM(D('itm'));
		let buffer = data.quoteResponse.result;
		for (let i = 0; i < buffer.length; i++) {
			optionsBySymbol[buffer[i].symbol].shortPut.forEach(function(contract) {
				if (contract.strike > 100*0.97*buffer[i].regularMarketPrice) {
					let li = makeli(buffer[i].symbol, contract);
					let col = addCol(buffer[i].regularMarketPrice, "75px", li);
					col.style.backgroundColor = "#dff";
					D('itm').appendChild(li);
					if (!monitorQuery.includes(buffer[i].symbol)) {
						monitorQuery.push(buffer[i].symbol);
						monitorMargin.push([contract.strike/100, (contract.strike/100) + 0.1*contract.strike/100]);
					}
				}
			});
			optionsBySymbol[buffer[i].symbol].shortCall.forEach(function(contract) {
				if (contract.strike < 100*1.03*buffer[i].regularMarketPrice) {
					let li = makeli(buffer[i].symbol, contract);
					let col = addCol(buffer[i].regularMarketPrice, "75px", li);
					col.style.backgroundColor = "#dff";
					D('itm').appendChild(li);
					if (!monitorQuery.includes(buffer[i].symbol)) {
						monitorQuery.push(buffer[i].symbol);	
						monitorMargin.push([(contract.strike/100) - 0.1*contract.strike/00, contract.strike/100]);
					}
				}
			});
		}			
		console.log(monitorQuery);
		submitTicker(monitorQuery.join(), monitorMargin);			
		d = new Date();
		D('msg').textContent = d.toLocaleTimeString();
		D('msg').style.backgroundColor = "#dff";
		setTimeout(function() {	D('msg').style.backgroundColor = "white"; }, 300);
		});
	});
});
}	
	
function findCallPair(symbol, defCall, shortCall) {	
	let data = optionsBySymbol[symbol];
	let maxGain = 0;
	let collateral = Infinity;
	let candidate = null;
	let seeker = defCall;
	if (!seeker) seeker = shortCall;
	if (defCall) {
		for (let j = 0; j < data.shortCall.length; j++) {
			evaluate(defCall, data.shortCall[j], data.shortCall[j]);
		}
	}
	if (shortCall) {
		for (let j = 0; j < data.defCall.length; j++) {
			evaluate(data.defCall[j], shortCall, data.defCall[j]);
		}
	}
	
	function evaluate(defCall, shortCall, subject) {
		if (defCall.expire >= shortCall.expire 
		    && (callGain(defCall, shortCall, subject) > maxGain || (maxGain == Infinity && callCollateral(defCall, shortCall) < collateral ))) {
			maxGain = callGain(defCall, shortCall, subject);
			collateral = callCollateral(defCall, shortCall);
			candidate = subject;
		}
	}

	function callCollateral(defCall, shortCall) {	
		if (defCall.strike > shortCall.strike) return defCall.strike - shortCall.strike;
		return 0;
	}

	function callGain(defCall, shortCall, subject) {
		if (!subject.friend) return Infinity;
		return subject.collateral - callCollateral(defCall, shortCall);
	}
	
	if (candidate) {
		let orphan = candidate.friend;
		if (orphan) clearOption(orphan);
		
		candidate.friend = seeker;
		seeker.friend = candidate;
		candidate.collateral = collateral;
		seeker.collateral = collateral;

		if (orphan) {
			if (defCall) findCallPair(symbol, orphan);
			else if (shortCall) findCallPair(symbol, null, orphan);
		}
	}	
}
	
function clearOption(option) {
	delete option.friend;
	delete option.release;
	delete option.collateral;
}
	
function findPutPair(symbol, defPut, shortPut) {	
	let data = optionsBySymbol[symbol];
	let maxGain = 0;
	let release = 0;
	let candidate = null;
	let seeker = defPut;
	if (!seeker) seeker = shortPut;
	if (defPut) {
		for (let j = 0; j < data.shortPut.length; j++) {
			evaluate(defPut, data.shortPut[j], data.shortPut[j]);
		}
	}
	if (shortPut) {
		for (let j = 0; j < data.defPut.length; j++) {
			evaluate(data.defPut[j], shortPut, data.defPut[j]);
		}
	}
	
	function evaluate(defPut, shortPut, subject) {
		if (defPut.expire >= shortPut.expire && putGain(defPut, shortPut, subject) > maxGain) {
			maxGain = putGain(defPut, shortPut, subject);
			release = putRelease(defPut, shortPut);
			candidate = subject;
		}
	}
	
	function putRelease(defPut, shortPut) {		
		if (defPut.strike < shortPut.strike) return defPut.strike;
		return shortPut.strike;		
	}

	function putGain(defPut, shortPut, subject) {
		if (!subject.friend) return putRelease(defPut, shortPut);
		return putRelease(defPut, shortPut) - subject.release;
	}

	if (candidate) {
		let orphan = candidate.friend;
		if (orphan) clearOption(orphan);
		
		candidate.friend = seeker;
		seeker.friend = candidate;
		candidate.release = release;
		seeker.release = release;
		
		candidate.collateral = candidate.strike - candidate.release;
		seeker.collateral = seeker.strike - seeker.release;
		
		if (orphan) {
			if (defPut) findPutPair(symbol, orphan);
			else if (shortPut) findPutPair(symbol, null, orphan);
		}
	}	
}
	
function noCondorCalls(symbol) {
	let data = optionsBySymbol[symbol];
	let totalCalls = 0;
	data.shortCall.forEach(function(contract) {
		if (contract.collateral !== undefined) totalCalls += contract.collateral;
		else console.log("CALL CONTRACT LACKS COLLATERAL");
	});	
	return totalCalls;
}
	
function noCondorPuts(symbol) {
	let data = optionsBySymbol[symbol];
	let totalPuts = 0;	
	data.shortPut.forEach(function(contract) {
		if (contract.collateral) totalPuts += contract.collateral;
		else totalPuts += contract.strike;
	});	
	return totalPuts;
}

function condor(symbol, build) {
	let data = optionsBySymbol[symbol];
	let callExpireTypes = {};
	let putExpireTypes = {};
	let pcsOnly = {};
	data.shortCall.forEach(function(contract) {
		if (!callExpireTypes[contract.expire]) {
					callExpireTypes[contract.expire] = {};
					putExpireTypes[contract.expire] = {};
					pcsOnly[contract.expire] = 0;
		}
		if (contract.collateral !== undefined) {
			if (!callExpireTypes[contract.expire][contract.strike]) callExpireTypes[contract.expire][contract.strike] = contract.collateral;
			else callExpireTypes[contract.expire][contract.strike] += contract.collateral;
		} else console.log("CALL CONTRACT LACKS COLLATERAL");
	});
	
	data.shortPut.forEach(function(contract) {
		if (!putExpireTypes[contract.expire]) {
			putExpireTypes[contract.expire] = {};
			pcsOnly[contract.expire] = 0;
		}
		if (contract.collateral) {
			if (!putExpireTypes[contract.expire][contract.strike]) putExpireTypes[contract.expire][contract.strike] = contract.collateral;
			else putExpireTypes[contract.expire][contract.strike] += contract.collateral;
		}
		else {
		//	if (!putExpireTypes[contract.expire][contract.strike]) putExpireTypes[contract.expire][contract.strike] = contract.strike;
		//	else putExpireTypes[contract.expire][contract.strike] += contract.strike;
			pcsOnly[contract.expire] += contract.strike;
		}
	});	
	
	let totalSaved = 0;
	for (let expiration in putExpireTypes) {
		for (let strike in putExpireTypes[expiration]) {
			for (let callStrike in callExpireTypes[expiration]) {
				if (parseInt(callStrike) > parseInt(strike)) {
					if (callExpireTypes[expiration][callStrike] <= putExpireTypes[expiration][strike]) {
						putExpireTypes[expiration][strike] -= callExpireTypes[expiration][callStrike];						
						totalSaved += callExpireTypes[expiration][callStrike];
						callExpireTypes[expiration][callStrike] = 0;
					}
					else {
						callExpireTypes[expiration][callStrike] -= putExpireTypes[expiration][strike];
						totalSaved += putExpireTypes[expiration][strike];
						putExpireTypes[expiration][strike] = 0;
						break;
					}
				}
			}
		}
	}
	
	let totalPuts = 0;
	let totalCalls = 0;
	let totalPCS = 0;
	
	if (build) incompleteCondorList[symbol] = {};
	for (let expiration in putExpireTypes) {		
		if (build && pcsOnly[expiration] > 0) {
			let li = makeli(symbol);
			li.title = 0 - pcsOnly[expiration];	
			if (dteMap[expiration]) addCol(dteMap[expiration] + " DTE", "75px", li);	
			else addCol(expiration.substring(5, 10), "75px", li);	
			addCol("PCS", "50px", li);
			let col = addCol("$" + pcsOnly[expiration], "100px", li);
			col.style.backgroundColor = "#dff";
			addOrdered(li, D('unpaired'));
			incompleteCondorList[symbol][expiration] = {call: true};
		}
		totalPCS += pcsOnly[expiration];
		
		let expirePuts = 0;
		for (let strike in putExpireTypes[expiration]) {
			expirePuts += putExpireTypes[expiration][strike];
		}
		if (build && expirePuts > 0) {
			let li = makeli(symbol);
			li.title = 0 - expirePuts;	
			if (dteMap[expiration]) addCol(dteMap[expiration] + " DTE", "75px", li);	
			else addCol(expiration.substring(5, 10), "75px", li);	
			addCol("call", "50px", li);
			let col = addCol("$" + expirePuts, "100px", li);
			col.style.backgroundColor = "#dff";
			addOrdered(li, D('unpaired'));
			incompleteCondorList[symbol][expiration] = {call: true};
		}
		totalPuts += expirePuts;
		
		let expireCalls = 0;
		for (let callStrike in callExpireTypes[expiration]) {
			expireCalls += callExpireTypes[expiration][callStrike];
		}
		
		if (build && expireCalls > 0) {
			let li = makeli(symbol);
			li.title = 0 - expireCalls;
			if (dteMap[expiration]) addCol(dteMap[expiration] + " DTE", "75px", li);	
			else addCol(expiration.substring(5, 10), "75px", li);	
			addCol("put", "50px", li);
			let col = addCol("$" + expireCalls, "100px", li);
			col.style.backgroundColor = "#dff";
			addOrdered(li, D('unpaired'));
			if (!incompleteCondorList[symbol][expiration]) incompleteCondorList[symbol][expiration] = {};
			incompleteCondorList[symbol][expiration].put = true;
		}
		totalCalls += expireCalls;
	}
					
	return totalSaved + totalPuts + totalCalls + totalPCS;
}
	
function makeli(symbol, contract) {
	let li = make('li');
	li.onmouseenter = function() { this.style.fontWeight = "bold"; }
	li.onmouseleave = function() { this.style.fontWeight = ""; }
	li.style.textAlign = "center";	
	addCol(symbol, "75px", li);	
	if (contract) {
		if (dteMap[contract.expire]) addCol(dteMap[contract.expire] + " DTE", "75px", li);	
		else addCol(contract.expire.substring(5, 10), "75px", li);	
		addCol(contract.type, "50px", li);
		addCol("$" + contract.strike/100, "75px", li);
	}
	return li;
}

function addCol(text, width, li) {								       
	let col = make('span');
	col.style.width = width;
	col.style.display = "inline-block";
	col.style.textAlign = "center";
	col.textContent = text;
	li.appendChild(col);  
	return col;
}		
	
function addOrdered(li, element) {
	let toAdd = true;
	for (let j = 0; j < element.children.length; j++) {
		if (parseFloat(li.title) < parseFloat(element.children[j].title)) {
			element.insertBefore(li, element.children[j]);
			toAdd = false;
			break;
		}
	}
	if (toAdd) element.appendChild(li);
}
	

///// Monitoring code //////////////////////////////////////////////////////
	
function submitTicker(myQuery, monitorMargin) {
	let query = 'https://query1.finance.yahoo.com/v7/finance/quote?symbols=' + D('tickerInput').value.replaceAll(" ", ",");	
	if (myQuery) query = 'https://query1.finance.yahoo.com/v7/finance/quote?symbols=' + myQuery.replaceAll(" ", ",");
	
	fetchData(query, 'GET').then(function(data) {	
	if (data.quoteResponse.result.length > 0) {
	for (let i = data.quoteResponse.result.length - 1; i > -1; i--) {
		let buffer = data.quoteResponse.result[i];
		let stock = buffer.symbol;
	
		if (!tickerList.includes(stock)) {			
			tickerList.push(stock);

			let newli = make("li");
			newli.id = stock;
			newli.style.textAlign = "center";
			newli.style.position = "relative";
	
			let newTicker = make("a");
			newTicker.id = stock + "-percent";
			newTicker.style.marginTop = "10px";
			newTicker.style.paddingLeft = "10px";
			newTicker.style.paddingRight = "10px";
			newTicker.textContent = stock + " " + round(buffer.regularMarketChange) + " (" + round(buffer.regularMarketChangePercent, true) + "%)";
			if (buffer.regularMarketChangePercent > 0) newTicker.style.color = "#1a8";
			else if (buffer.regularMarketChangePercent < 0) newTicker.style.color = "#FF0000";
			newTicker.href = "https://finance.yahoo.com/quote/" + stock;
			newTicker.target = "_blank";
	
			let newTickerX = make("button");
			newTickerX.textContent = "X";
			newTickerX.style.position = "absolute";
			newTickerX.style.top = "15px";
			newTickerX.style.right = "0px";
			newTickerX.onclick = function() { 
				tickerList.splice(tickerList.indexOf(stock), 1); 
				remove(newli); 
				delete volumes[stock];
				delete prices[stock];
			};	
	
			let lowerBound = make("input");
			lowerBound.type = "text";
			if (monitorMargin) lowerBound.value = monitorMargin[i][0];
			lowerBound.id = stock + "-lower";
			lowerBound.style.width = "80px";
			setInput(lowerBound, stock);
								       
			let lowerMargin = make("input");
			lowerMargin.type = "text";							
			lowerMargin.id = stock + "-lowerMargin";
			lowerMargin.style.width = "80px";
			setInput(lowerMargin, stock);
			lowerMargin.style.marginLeft = "10px";  	
									      
			let lowerPercent = make("input");
			lowerPercent.type = "text";
			lowerPercent.value = defaultLower;
			lowerPercent.id = stock + "-lowerPercent";
			lowerPercent.style.width = "60px";	
			setInput(lowerPercent, stock);
								       
			let upperBound = make("input");
			upperBound.type = "text";
			if (monitorMargin) upperBound.value = monitorMargin[i][1];
			upperBound.id = stock + "-upper";
			upperBound.style.width = "80px";
			setInput(upperBound, stock);		
								       
			let upperMargin = make("input");
			upperMargin.type = "text";							     
			upperMargin.id = stock + "-upperMargin";
			upperMargin.style.width = "80px";
			setInput(upperMargin, stock);
			upperMargin.style.marginRight = "10px";  	
								       
			let upperPercent = make("input");
			upperPercent.type = "text";
			upperPercent.value = defaultUpper;
			upperPercent.id = stock + "-upperPercent";
			upperPercent.style.width = "60px";
			setInput(upperPercent, stock);	
	
			let current = make("div");
			current.textContent = round(buffer.regularMarketPrice * 1);
			current.id = stock + "-current";
			current.style.display = "inline-block";
			current.style.paddingLeft = "10px";  	
			current.style.paddingRight = "10px";  			      
										      
			let slider = make("input");
			slider.id = stock + "-slider";
			slider.autocomplete = "off";
			slider.style.flexGrow = "1";							      
			slider.type = "range";
			slider.min = 0;
			slider.max =100;
			slider.step = 1;
			slider.value = 50;
			slider.style.marginLeft = "10px";
			slider.style.marginRight = "10px";
			slider.style.cursor = "pointer";
			slider.style.touchAction = "none";
			slider.oninput = function() {  updateDisplay(stock, slider); };
								
	
			let li1 = make('div');	    
			li1.appendChild(newTicker);
			li1.appendChild(newTickerX);
										      
			let li2 = make('div');	
			
			let parenth1 = make("span");
			parenth1.textContent = "(";
			li2.appendChild(parenth1);	
			li2.appendChild(lowerPercent);			      
			let percentsign1 = make("span");
			percentsign1.textContent = " %)";
			li2.appendChild(percentsign1);
							
			li2.appendChild(lowerMargin);
			li2.appendChild(current);
			li2.appendChild(upperMargin);
							
			let parenth2 = make("span");
			parenth2.textContent = "(";
			li2.appendChild(parenth2);				      
			li2.appendChild(upperPercent);									      
			let percentsign2 = make("span");
			percentsign2.textContent = " %)";	   
			li2.appendChild(percentsign2);	      
											      
			let li3 = make('div');	
			li3.style.display = "flex";
			li3.appendChild(lowerBound);
			li3.appendChild(slider);	
			li3.appendChild(upperBound);			      
										      
			newli.appendChild(li1);		
			newli.appendChild(li2);		
			newli.appendChild(li3);	
								
			D('stocklist').insertBefore(newli, D('stocklist').firstChild);
			
			if (monitorMargin) updateDisplay(stock, upperBound);
			else updateDisplay(stock, upperPercent);
			volumes[stock] = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1];
			prices[stock] = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1];
										       
		} else {
			let dailyPercent = buffer.regularMarketChangePercent;
			D(stock + "-current").textContent = round(buffer.regularMarketPrice);	
			D(stock + "-percent").textContent = stock + " " + round(buffer.regularMarketChange) + " (" + round(dailyPercent, true) + "%)";

			if (dailyPercent > 0) D(stock + "-percent").style.color = "#1a8";
			else if (dailyPercent < 0) D(stock + "-percent").style.color = "#F00";
			else D(stock + "-percent").style.color = "#333";	
			D('stocklist').insertBefore(D(stock), D('stocklist').firstChild);
			updateDisplay(stock);
		}
	
		D('tickerInput').value = "";
	}
	} else D('msg').textContent = "Ticker not found.";
	}).catch(function(error) { 
		console.log(error); 
		var e = new Date();
		D('msg').textContent = d.toLocaleTimeString() + " (Refresh failed: " +  e.toLocaleTimeString() + ")";
	});	
}
	
function update() {
	if (tickerList.length > 0) {
	fetchData('https://query1.finance.yahoo.com/v7/finance/quote?symbols=' + tickerList.join(), 'GET').then(function(data) {	
	if (data.quoteResponse.result) {	
		data.quoteResponse.result.forEach(function(stockData) {
			let stock = stockData.symbol;
			let price = stockData.regularMarketPrice;
			let volume = stockData.regularMarketVolume;
			let dailyPercent = stockData.regularMarketChangePercent;
			let daily = stockData.regularMarketChange;
			D(stock + "-current").textContent = round(price);	
			D(stock + "-percent").textContent = stock + " " + round(daily) + " (" + round(dailyPercent, true) + "%)";
	
			if (dailyPercent > 0) D(stock + "-percent").style.color = "#1a8";
			else if (dailyPercent < 0) D(stock + "-percent").style.color = "#F00";
			else D(stock + "-percent").style.color = "#333";
			updateDisplay(stock);
						  
			if (volumes[stock][volumes[stock].length - 1] != volume ||
			    prices[stock][prices[stock].length - 1] != price) {
				volumes[stock].shift();			  
				volumes[stock].push(volume);
				prices[stock].shift();			  
				prices[stock].push(price);
									  
				function avgVariation(arr) {
					let diffarr = [];
					for (let i = 0; i < arr.length - 1; i++) {
						if (arr[i + 1] > 0 && arr[i] > 0) {
							if (arr[i + 1] > arr[i]) diffarr.push(arr[i + 1] - arr[i]);
							else diffarr.push(arr[i] - arr[i + 1]);
						}
					}
					if (diffarr.length < arr.length - 2) return -1;

					var total = 0;
					for(var i = 0; i < diffarr.length; i++) {
					    total += diffarr[i];
					}
					return avg = total / diffarr.length;
				}

				function currentVariation(arr) {
					if (arr[arr.length - 1] > 0 && arr[arr.length - 2] > 0) return arr[arr.length - 1] - arr[arr.length - 2];
					else return -1;
				}

				let avgVol = avgVariation(volumes[stock]);
				let avgPrice = avgVariation(prices[stock]);
				let curVol = currentVariation(volumes[stock]);
				let curPrice = currentVariation(prices[stock]);
	
				let notify = false;
				function activityNotification(str) {
					if (D(stock + "-percent").style.backgroundColor == "") {
						if (active(D('soundButton'))) {
							if (curPrice > 0) D('audio').play();
							else D('audiodown').play();
						}
						if (active(D('notificationButton'))) new Notification(stock + "'s " + str + " activity is elevated.");
					}
					notify = true;
				}

				if (avgPrice > 0 && curPrice > 0 && (curPrice > 4*avgPrice || curPrice + 4*avgPrice < 0)) activityNotification("price");
				if (avgVol > 0 && curVol > 0  && (curVol > 4*avgVol || curVol + 4*avgVol < 0)) activityNotification("volume");
				if (notify) {
					if (curPrice > 0) D(stock + "-percent").style.backgroundColor = "#dfd";
					else D(stock + "-percent").style.backgroundColor = "#fdd";   
					console.log(stock + " activity:");
					if (curVol > avgVol) console.log(curVol + " > " + avgVol);
					if (curPrice > avgPrice) console.log(curPrice + " > " + avgPrice);
				} else D(stock + "-percent").style.backgroundColor = "";
			}
		});	
	} else {
		var e = new Date();
		D('msg').textContent = d.toLocaleTimeString() + " (Refresh failed: " +  e.toLocaleTimeString() + ")";
	}
	}).catch(function(error) { 
		console.log(error); 	
		var e = new Date();
		D('msg').textContent = d.toLocaleTimeString() + " (Refresh failed: " +  e.toLocaleTimeString() + ")";
	});	
	}
}
						     
function updateDisplay(stock, fixed) {			
	let current = parseFloat(D(stock + "-current").textContent);
	let upelt = D(stock + "-upperPercent");
	let lpelt = D(stock + "-lowerPercent");	
	let lower = D(stock + "-lower");
	let upper = D(stock + "-upper");
	let upperMargin = D(stock + "-upperMargin");
	let lowerMargin = D(stock + "-lowerMargin");
	let slider = D(stock + "-slider");
						 
	if (!upelt.value) upelt.value = 0;
	if (!lpelt.value) lpelt.value = 0;
	if (!upperMargin.value) upperMargin.value = 0;
	if (!lowerMargin.value) lowerMargin.value = 0; 
	if (!lower.value) lower.value = current;
	if (!upper.value) upper.value = current;
					     
	if (fixed == lpelt || fixed == upelt) {				
		lower.value = round( current * (1 - val(lpelt)/100));
		upper.value = round( current * (1 + val(upelt)/100));
	} else if (fixed == upperMargin || fixed == lowerMargin) {	
		lower.value = round(current - val(lowerMargin));
		upper.value = round(current + val(upperMargin));
	} else if (fixed == slider) {
		let oldLower = val(lower);
		lower.value = round(current - (slider.value * (val(upper) - val(lower)) / 100));
		upper.value = round(val(upper) - oldLower + val(lower));
	}	 
				 
	if (lpelt != document.activeElement) lpelt.value = round(100*(current - val(lower))/current, true);
	if (upelt != document.activeElement) upelt.value = round(100*(val(upper) - current)/current, true);
	if (upperMargin != document.activeElement) upperMargin.value = round(val(upper) - current);
	if (lowerMargin != document.activeElement) lowerMargin.value = round(current - val(lower));
	if (val(upper) > val(lower)) {
		slider.value = inDollars((current - val(lower))/(val(upper) - val(lower)));
		if (slider.value > 100) slider.value = 100;
		if (slider.value < 0) slider.value = 0;
	} else { 
		if (current > val(upper)) slider.value = 100;
		else if (current < val(lower)) slider.value = 0;
		else slider.value = 50;
	}
						 
	if (val(lower) > current) {
		if (lower.style.fontWeight != "bold") {
			if (active(D('soundButton'))) D('audiodown').play();
			if (active(D('notificationButton'))) new Notification(stock + " is down to $" + current);
			lower.style.fontWeight = "bold";
			lpelt.style.fontWeight = "bold";
			lowerMargin.style.fontWeight = "bold";
		}
	} else {
		lower.style.fontWeight = "initial";
		lpelt.style.fontWeight = "initial";
		lowerMargin.style.fontWeight = "initial";
	}
	if (val(upper) < current) {
		if (upper.style.fontWeight != "bold") {
			if (active(D('soundButton'))) D('audio').play();
			if (active(D('notificationButton'))) new Notification(stock + " is up to $" + current);
			upper.style.fontWeight = "bold";
			upelt.style.fontWeight = "bold";
			upperMargin.style.fontWeight = "bold";
		}
	} else {
		upper.style.fontWeight = "initial";
		upelt.style.fontWeight = "initial";
		upperMargin.style.fontWeight = "initial";
	}
					      
	if (lower.style.fontWeight == "bold") {
		D(stock + "-current").style.fontWeight = "bold";
		D(stock + "-current").style.color = "#F00";
	} else if (upper.style.fontWeight == "bold") {
		D(stock + "-current").style.fontWeight = "bold";
		D(stock + "-current").style.color = "#3b7";
	} else {	      
		D(stock + "-current").style.fontWeight = "initial";
		D(stock + "-current").style.color = "#333";
	}
}
	
function round(num, percent) { 
	if (num < 1 && !percent) return Math.round(num*1000)/1000;
	return roundTwo(num);
}
	
function roundTwo(num) { return Math.round(num*100)/100; }
	
function inDollars(num) { return Math.round(num*100); }
	
function setInput(elt, stock) {
	elt.style.textAlign = "center";	
	elt.onfocus = function() { elt.select(); }
	elt.onkeydown = function() { 
		if ((event.keyCode > 57 && event.keyCode < 91) && !event.altKey && !event.ctrlKey) event.preventDefault();
	}
	elt.onkeyup = function() {
		if (event.keyCode == 13) {
			event.preventDefault(); 
			elt.blur();
		}
	};   
	if (stock) elt.onblur = function() { updateDisplay(stock, elt); };   
} 
	
function clickable(elt) {
	elt.style.cursor = "pointer";
	elt.style.backgroundColor = "#ddf";	
}
function declickable(elt) {
	elt.style.pointerEvents = "none";
	elt.style.backgroundColor = "";	
}
function deactivate(but, str) { 
	but.classList.remove("active");
	but.textContent = str;
}										       
function activate(but, str) { 
	but.classList.add("active");
	but.textContent = str;
}
function active(but) { return but.classList.contains("active"); }
function remove(element) { element.parentNode.removeChild(element);}	
function val(elt) { return parseFloat(elt.value); }

function toggleAuto(elt) {
	if (active(elt)) deactivate(elt, "Order-Chaining Off");
	else activate(elt, "Order-Chaining On");
}
	
function toggleSound(elt) {
	if (active(elt)) deactivate(elt, "Sound Off");
	else {	
		activate(elt, "Sound On");
		D('audio').play();
	}
}
function toggleAlerts(elt) {
	if (yahootimer) {
		deactivate(elt, "Auto-Refresh Off");
		clearInterval(yahootimer);
		yahootimer = "";
		for (let x in prices) {
			prices[x] = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1];
			volumes[x] = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1];
		}
	} else {	
		activate(elt, "Auto-Refresh On");
		update(); 
		yahootimer = setInterval(function() { update(); }, 10000);
	}
}
	
function toggleNotifications(elt) {
	if (elt.textContent == "Notifications On") deactivate(elt, "Notifications Off");
	else {	
		if (!("Notification" in window)) alert("This browser does not support desktop notification");
		else if (Notification.permission === "granted") activate(elt, "Notifications On");
		else {
		Notification.requestPermission().then(function (permission) {
			if (permission === "granted") activate(elt, "Notifications On");
		});
		}	
	}
}

</script>
