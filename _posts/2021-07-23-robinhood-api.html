---
title: "Options collateral analysis via the Robinhood API"
---

A Robinhood API applet to analyze your options collateral. Login is persistent via local storage.




<div style="margin-top:30px">
	
	
	<div id="orderPage" style="text-align:center; display:none; padding-top:20px; margin-bottom:20px; border-bottom:solid;">	
		<div style="padding-top:20px">Orders:
		<ul style="overflow:auto; max-height:50vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="orders"></ul>
		</div>		
	</div>
	
	<div id="profilePage" style="text-align:center; display:none; padding-top:20px; border-bottom:solid; margin-bottom:40px">
		<div style="text-align:center;">
		<button onclick="getData();">Account Value</button>
		<button id="optionButton" onclick="getData(); getOptions();">Options Collateral</button>
		<button id="optionButton" onclick="logout();">Log Out</button>
		</div>		
		<div style="font-weight:bold; padding:20px">Total value: <span id="accountValue">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cash available: <span id="cash"></span></div>	
		<div style="padding-top:20px">Near or in the money:
		<ul style="overflow:auto; max-height:50vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="itm"></ul>
		</div>			
		<div style="padding-top:20px">Incomplete spreads:
		<ul style="overflow:auto; max-height:50vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="singles"></ul>
		</div>		
		<div style="padding-top:20px">Incomplete condors:
		<ul style="overflow:auto; max-height:50vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="unpaired"></ul>
		</div>		
		<div style="padding-top:20px">Spread buybacks:
		<ul style="overflow:auto; max-height:50vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="release"></ul>
		</div>		
		<div style="padding-top:20px">Condor buybacks:
		<ul style="overflow:auto; max-height:50vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="condorRelease"></ul>
		</div>				
		<div style="padding-top:20px; padding-bottom:20px;">Partial condor buybacks:
		<ul style="overflow:auto; max-height:50vh; list-style-type:none; padding-left:0px;margin-bottom:20px;" id="ncRelease"></ul>
		</div>		
	</div>
	
	
	<form id="loginForm" onsubmit="submitLoginForm(); return false;">	
		Username:<br>
		<input id="loginUsername" type="text" autocapitalize="off" autocomplete="off">
		<br><br>
		Password:<br>
		<input id="loginPassword" type="password" autocomplete="off">		
		<br><br>
		<div style="text-align:left; padding-left:10px">
			<button id="smallloginbut" type="submit">Log In</button>
			<button type="button" style="margin-right:10px; margin-bottom:10px;" onclick="D('loginForm').reset()">Cancel</button>
    		</div>
	</form> 
	
	<form id="MFAForm" onsubmit="submitMFAForm(); return false;" style="padding-top:20px; display:none">	
		MFA:<br>
		<input id="loginMFA" type="password" autocomplete="off">		
		<br><br>
		<div style="text-align:left; padding-left:10px">
			<button id="smallloginbut" type="submit">Submit</button>
			<button type="button" style="margin-right:10px; margin-bottom:10px;" onclick="D('MFAForm').reset()">Cancel</button>
    		</div>
	</form> 
</div>

<script>/////////////////////////////////////////////////////////

var currentID;
var form = {};
var authData = {};
var authHeader = {};
var accountURL = "";
	
var optionsBySymbol = {};	
	
if (typeof(Storage) !== "undefined") {
	authHeader = {'Authorization': localStorage.getItem("authString") };
	if (localStorage.getItem("authString")) {
		D('profilePage').style.display = "block";
		D('orderPage').style.display = "block";
	}
} 	
	
function D(str) { return document.getElementById(str); }
	
function makeli(symbol, contract) {
	let li = make('li');
	li.onmouseenter = function() { this.style.fontWeight = "bold"; }
	li.onmouseleave = function() { this.style.fontWeight = ""; }
	li.style.textAlign = "center";	
	addCol(symbol, "75px", li);	
	if (contract) {
		addCol(contract.expire, "125px", li);	
		addCol(contract.type, "50px", li);
		addCol("$" + contract.strike/100, "75px", li);
	}
	return li;
}
	
function logout() {
	D('cash').textContent = "";
	D('accountValue').textContent = "\xa0\xa0\xa0\xa0\xa0";
	wipeDOM();
	
	currentID = "";
	form = {};
	authData = {};
	authHeader = {};	
	optionsBySymbol = {};
	
	hide('profilePage');
	hide('orderPage');
	
	// if (typeof(Storage) !== "undefined") localStorage.setItem("authString", "");
}
	
function clearDOM(myNode) {
	while (myNode.firstChild) { myNode.removeChild(myNode.lastChild); }
}
	
function wipeDOM() {	
	clearDOM(D('orders'));
	clearDOM(D('singles'));
	clearDOM(D('unpaired'));
	clearDOM(D('release'));
	clearDOM(D('condorRelease'));
	clearDOM(D('ncRelease'));
	clearDOM(D('itm'));
}
	
function addCol(text, width, li) {								       
	let col = make('span');
	col.style.width = width;
	col.style.display = "inline-block";
	col.style.textAlign = "center";
	col.textContent = text;
	li.appendChild(col);  
	return col;
}		
	
function addOrdered(li, element) {
	let toAdd = true;
	for (let j = 0; j < element.children.length; j++) {
		if (parseFloat(li.title) < parseFloat(element.children[j].title)) {
			element.insertBefore(li, element.children[j]);
			toAdd = false;
			break;
		}
	}
	if (toAdd) element.appendChild(li);
}
	
function fetchData(url, method, data) {
	if (data) {
	return fetch("https://sandboxansyble.herokuapp.com/cors/", 
		{cache:'no-cache', headers: {method: method, url: url, 'json-data': JSON.stringify(data) }}).then(function(response) {
		return response.json();
	});
	} else {
	return fetch("https://sandboxansyble.herokuapp.com/cors/", 
		{cache:'no-cache', headers: {method: method, url: url }}).then(function(response) {
		return response.json();
	});						  
	}
}
	
function generate_device_token() {
    let rands = [];
    for (let i = 0; i < 16; i++) {
        rands.push((Math.round(4294967296.0 * Math.random()) >> ((3 & i) << 3)) & 255);
    }

    let hexa = [];
    for (let i = 0; i < 256; i++) {	
	let myhex = (i + 256).toString(16).substring(1);
        hexa.push(myhex);
    }

    let id = "";
    for (let i = 0; i < 16; i++) {
        id += hexa[rands[i]];
        if ((i == 3) || (i == 5) || (i == 7) || (i == 9)) id += "-";
    }
   return id;
}

function submitLoginForm() {
	let mytoken = generate_device_token();
	form = {
		'client_id': 'c82SH0WZOsabOXGP2sxqcj34FxkvfnWRZBKlBjFS',
		'expires_in': 86400,
		'grant_type': 'password',
		'password': D('loginPassword').value,
		'username': D('loginUsername').value,
		'scope': 'internal',
		'challenge_type': "sms",
		'device_token': mytoken
	};

	fetchData("https://api.robinhood.com/oauth2/token/", 'POST', {form:form}).then(function(data){
		show('MFAForm');
		if (data.challenge) currentID = data.challenge.id;
	});
}
  
function submitMFAForm() {
	fetchData('https://api.robinhood.com/challenge/' + currentID + '/respond/', 'POST', { form:{ 'response': D('loginMFA').value }}).then(function(data){
		fetchData("https://api.robinhood.com/oauth2/token/", 'POST', {form:form, headers:{'X-ROBINHOOD-CHALLENGE-RESPONSE-ID':currentID}}).then(function(data){
			hide('MFAForm');
			show('profilePage');
			show('orderPage');
			authData = data;
			authHeader = {'Authorization':data.token_type + " " + data.access_token};
	
			if (typeof(Storage) !== "undefined") localStorage.setItem("authString", data.token_type + " " + data.access_token);
		});
	});
}
	
	
	
	
///// After logging in //////////////////////////////////////////////////////
	
	
function getData() {	
	fetchData("https://api.robinhood.com/accounts/", 'GET', {headers:authHeader}).then(function(data) {
		//D('cash').textContent = "Cash available: $" + parseFloat(data.results[0].cash_available_for_withdrawal).toFixed(2);
		accountURL = data.results[0].url;
		
		console.log("Accounts");
		console.log(data);
	});
	fetchData("https://api.robinhood.com/portfolios/", 'GET', {headers:authHeader}).then(function(data) {
		let growth = data.results[0].equity - data.results[0].equity_previous_close;		
		if (growth > 0) D("accountValue").style.color = "#1a8";
		else if (growth < 0) D("accountValue").style.color = "#F00";
		
		D('accountValue').textContent = "$" + parseFloat(data.results[0].equity).toFixed(2) + " ($" + parseFloat(growth).toFixed(2) +")";
		D('cash').textContent = "$" + parseFloat(data.results[0].withdrawable_amount).toFixed(2);
		
		console.log("Portfolios");
		console.log(data);
	});
}	
	
function getOptions() {	
D('optionButton').disabled = true;
	
	
fetchData('https://api.robinhood.com/options/orders/', 'GET', { headers:authHeader }).then(function(data) {
	console.log("All open orders:");
	console.log(data);
	
	for (let i = 0; i < data.results.length; i++) {	
		if (data.results[i].cancel_url) {
		fetchData(data.results[i].legs[0].option, 'GET').then(function(optionData) {
			let json = data.results[i];
			let contract = {type: optionData.type, expire:optionData.expiration_date, strike:Math.round(parseFloat(optionData.strike_price)*100)};
			let symbol = data.results[i].chain_symbol;
			
			let orderli = makeli(symbol, contract);
			let col = addCol(json.legs[0].side, "75px", orderli);
			col.style.backgroundColor = "#dff";
			col = addCol(json.legs[0].position_effect, "75px", orderli);
			col.style.backgroundColor = "#dff";
			col = addCol(parseFloat(json.price).toFixed(2), "75px", orderli);
			col.style.backgroundColor = "#dff";
			let processedCol = addCol(parseFloat(json.processed_quantity), "75px", orderli);
			let msg = addCol("Pending...", "calc(100% - 650px)", orderli);

			function orderStatus(data) {
				if (parseFloat(data.processed_quantity) > 0) {
					processedCol.textContent = "$" + parseFloat(data.processed_premium).toFixed(2);
					msg.textContent = "Partially completed...";
				}								
				if (Math.round(parseFloat(data.pending_quantity)) == 0) {
					msg.textContent = "Completed!";
					msg.style.pointerEvents = "none";
					msg.style.backgroundColor = "";	
				}
			}
			orderStatus(json);
			
			orderli.onclick = function() {
				fetchData('https://api.robinhood.com/options/orders/' + json.id, 'GET', { headers:authHeader, json:json }).then(function(data) {
					console.log("Checking for update on status for order:");
					console.log(data);
					orderStatus(data);
				});
			}

			msg.style.cursor = "pointer";
			msg.style.backgroundColor = "#ddf";		
			msg.onclick = function() {
				if (confirm("Cancel " + json.legs[0].side + "ing?")) {
				fetchData(json.cancel_url, 'POST', { headers:authHeader }).then(function(data) {
					console.log("The response to the cancel request: ");
					console.log(data);
					if (data.detail) msg.textContent = data.detail;
					else {
						processedCol.textContent = 'X';
						msg.textContent = "Cancelled!";
						msg.style.pointerEvents = "none";
						msg.style.backgroundColor = "";
					}
				});
				}
			}
			D('orders').appendChild(orderli);
		});
		}
	}
});
	
	
	
fetchData("https://api.robinhood.com/options/positions/?nonzero=True", 'GET', { headers:authHeader }).then(function(data) {
	console.log(data);
	let accountOptions = data.results;

	let promises = [];
	optionsBySymbol = {};
	taskBySymbol = {};
	for (let i = 0; i < accountOptions.length; i++) {			
		if (!optionsBySymbol[accountOptions[i].chain_symbol]) {
			optionsBySymbol[accountOptions[i].chain_symbol] = {shortCall:[], shortPut:[], defCall:[], defPut:[]};
			taskBySymbol[accountOptions[i].chain_symbol] = [];
		}
		
		let task = fetchData(accountOptions[i].option, 'GET').then(function(optionData) {
			let quantity = parseInt(accountOptions[i].quantity);
			for (let j = 0; j < quantity; j++) {
				let dat = {tick:optionData.min_ticks.below_tick, url:optionData.url, type: optionData.type, expire:optionData.expiration_date, strike:Math.round(parseFloat(optionData.strike_price)*100)};
				if (accountOptions[i].type == "short") {
					if (optionData.type == "call") optionsBySymbol[optionData.chain_symbol].shortCall.push(dat);
					else optionsBySymbol[optionData.chain_symbol].shortPut.push(dat);
				}
				if (accountOptions[i].type == "long") {
					if (optionData.type == "call") optionsBySymbol[optionData.chain_symbol].defCall.push(dat);
					else optionsBySymbol[optionData.chain_symbol].defPut.push(dat);
				}
			}
		});
		promises.push(task);
		taskBySymbol[accountOptions[i].chain_symbol].push(task);
	}
	
	let queryString = "";
	wipeDOM();
	for (let symbol in taskBySymbol) {
		queryString += symbol + ",";
		Promise.all(taskBySymbol[symbol]).then(function() {
			optionsBySymbol[symbol].shortPut.sort(function(b, a) {
				if (a.expire > b.expire) return 1;
				else if (a.expire < b.expire) return -1;
				else if (a.strike < b.strike) return 1;
				else if (a.strike > b.strike) return -1;
				else return 0;					
			});
			optionsBySymbol[symbol].defPut.sort(function(b, a) { 
				if (a.expire < b.expire) return 1;
				else if (a.expire > b.expire) return -1;
				else if (a.strike < b.strike) return 1;
				else if (a.strike > b.strike) return -1;
				else return 0;					
			});

			let append = optionsBySymbol[symbol].shortCall.length - optionsBySymbol[symbol].defCall;
			for (let i = 0; i < append; i++) {
				 optionsBySymbol[symbol].defCall.push({expire:"never", strike:0});
			}

			optionsBySymbol[symbol].shortCall.sort(function(b, a) {
				if (a.expire > b.expire) return 1;
				else if (a.expire < b.expire) return -1;
				else if (a.strike > b.strike) return 1;
				else if (a.strike < b.strike) return -1;
				else return 0;					
			});
			optionsBySymbol[symbol].defCall.sort(function(b, a) {
				if (a.expire < b.expire) return 1;
				else if (a.expire > b.expire) return -1;
				else if (a.strike > b.strike) return 1;
				else if (a.strike < b.strike) return -1;
				else return 0;					
			});

			for (let i = 0; i < optionsBySymbol[symbol].shortPut.length; i++) {
				findPutPair(symbol, null, optionsBySymbol[symbol].shortPut[i]);
			}
			for (let i = 0; i < optionsBySymbol[symbol].shortCall.length; i++) {
				findCallPair(symbol, null, optionsBySymbol[symbol].shortCall[i]);
			}
			let totalCollateral = condor(symbol, true);
			let totalPutCollateral = noCondorPuts(symbol);
			let totalCallCollateral = noCondorCalls(symbol);

			for (let i = 0; i < optionsBySymbol[symbol].shortPut.length; i++) {
				let me = optionsBySymbol[symbol].shortPut[i];
				let myStrike = me.strike;
				let friend = me.friend;
				if (friend) {
					clearOption(friend);
					clearOption(me);
					me.strike = 0;

					findPutPair(symbol, friend);
					me.closeRelease = totalCollateral - condor(symbol);
					me.ncRelease = totalPutCollateral - noCondorPuts(symbol);

					me.strike = myStrike;
					findPutPair(symbol, null, me);
				} else me.closeRelease = myStrike;
			}

			for (let i = 0; i < optionsBySymbol[symbol].shortCall.length; i++) {
				let me = optionsBySymbol[symbol].shortCall[i];
				let myExpire = me.expire;
				let friend = me.friend;

				clearOption(friend);
				clearOption(me);
				me.expire = "neverplus";
				me.collateral = 0;

				findCallPair(symbol, friend);			
				me.closeRelease = totalCollateral - condor(symbol);
				me.ncRelease = totalCallCollateral - noCondorCalls(symbol);

				me.condorPair = [];
				for (let j = 0; j < optionsBySymbol[symbol].shortPut.length; j++) {
					let mypair = optionsBySymbol[symbol].shortPut[j];
					if (myExpire == mypair.expire) {
						let myPairStrike = mypair.strike;
						let pairFriend = mypair.friend;
						if (pairFriend) {
							clearOption(pairFriend);
							clearOption(mypair);
							mypair.strike = 0;

							findPutPair(symbol, pairFriend);
							me.condorPair.push({condorPair:mypair, condorRelease:totalCollateral - condor(symbol)});

							mypair.strike = myPairStrike;
							findPutPair(symbol, null, mypair);
						}
					}
				}

				me.expire = myExpire;
				delete me.collateral;
				findCallPair(symbol, null, me);
			}
			
			let d = new Date(Date.now() + 1000*60*60*24*21).toISOString();	
			fetch("https://api.tdameritrade.com/v1/marketdata/chains?apikey=T1V8GYUYK3GKC7HG3L23O9XBJ5OH1C4F&symbol=" 
				+ symbol + "&range=OTM&toDate=" + d).then(function(response) {
				return response.json();
			}).then(function(data) {
			console.log(data);
			if (data.status == "SUCCESS") {
				let dateMapData = {};
				for (let contractDate in data.putExpDateMap) {
					let expiration = contractDate.substring(0, 10);
					dateMapData[expiration] = contractDate;
				}					
				function dateMap(expiration) { return dateMapData[expiration]; }
				function strikeMap(strike) { return (strike/100).toFixed(1).toString();	}
					
				function createSingleOrder(li, contract, prem) {
				li.firstChild.style.cursor = "pointer";	
				li.firstChild.style.backgroundColor = "#ddf";	
				li.firstChild.onclick = function() {
				if (confirm("Proceed to sell this orphan defensive leg?")) {
					let json = {
						'account': accountURL,
						'direction': 'credit',
						'time_in_force': 'gfd',
						'legs': [{'position_effect': 'close', 'side': 'sell', 'ratio_quantity': 1, 'option': contract.url }],
						'type': 'limit',
						'trigger': 'immediate',
						'price': prem,
						'quantity': 1,
						'override_day_trade_checks': false,
						'override_dtbp_checks': false,
						'ref_id': generate_device_token()
					}
					console.log(json);
					fetchData('https://api.robinhood.com/options/orders/', 'POST', { headers:authHeader, json:json }).then(function(data) {
						console.log("The response to the order: ");
						console.log(data);

						let orderli = makeli(symbol, contract);
						// orderli.style.marginBottom = "10px";
						if (data.detail) addCol(data.detail, "calc(100% - 350px)", orderli);
						else {
							li.style.color = "#aaa";
							li.firstChild.style.backgroundColor = "";
							li.firstChild.style.pointerEvents = "none";

							let col = addCol(json.legs[0].side, "75px", orderli);
							col.style.backgroundColor = "#dff";
							col = addCol(json.legs[0].position_effect, "75px", orderli);
							col.style.backgroundColor = "#dff";
							col = addCol(prem.toFixed(2), "75px", orderli);
							col.style.backgroundColor = "#dff";
							let processedCol = addCol(parseFloat(data.processed_quantity), "75px", orderli);
							let msg = addCol("Pending...", "calc(100% - 650px)", orderli);

							function orderStatus(data) {
								if (parseFloat(data.processed_quantity) > 0) {
									processedCol.textContent = "$" + parseFloat(data.processed_premium).toFixed(2);
									msg.textContent = "Partially completed...";
								}								
								if (Math.round(parseFloat(data.pending_quantity)) == 0) {
									msg.textContent = "Completed!";
									msg.style.pointerEvents = "none";
									msg.style.backgroundColor = "";	
								}
							}
							orderStatus(data);
							
							orderli.onclick = function() {
								fetchData('https://api.robinhood.com/options/orders/' + data.id, 'GET', { headers:authHeader}).then(function(data) {
									console.log("Checking for update on status for order:");
									console.log(data);
									orderStatus(data);
								});
							}

							msg.style.cursor = "pointer";
							msg.style.backgroundColor = "#ddf";		
							msg.onclick = function() {										
							if (confirm("Cancel selling this orphan defensive leg?")) {
								fetchData(data.cancel_url, 'POST', { headers:authHeader }).then(function(data) {
									console.log("The response to the cancel request: ");
									console.log(data);
									if (data.detail) msg.textContent = data.detail;
									else {
										processedCol.textContent = 'X';
										msg.textContent = "Cancelled!";
										msg.style.pointerEvents = "none";
										msg.style.backgroundColor = "";	
										li.style.color = "";
										li.firstChild.style.backgroundColor = "#ddf";
										li.firstChild.style.pointerEvents = "";
										createSingleOrder(orderli, contract, prem - parseFloat(contract.tick));
									}
								});
							}
							}
						}
						D('orders').appendChild(orderli);
					});
				}
				}
				}
				
				optionsBySymbol[symbol].defPut.forEach(function(contract) {
					if (!contract.friend) {
						let li = makeli(symbol, contract);
						let prem = 0;
						if (data.putExpDateMap[dateMap(contract.expire)]) {
							if (!(data.putExpDateMap[dateMap(contract.expire)][strikeMap(contract.strike)])) prem = -1; // this is in the money
							else prem = data.putExpDateMap[dateMap(contract.expire)][strikeMap(contract.strike)][0].bid;
						}
						let col = addCol(prem.toFixed(2), "75px", li);
						if (prem > 0) col.style.backgroundColor = "#dff";
						D('singles').appendChild(li);
						
						createSingleOrder(li, contract, prem + parseFloat(contract.tick));
					}
				});

				optionsBySymbol[symbol].defCall.forEach(function(contract) {
					if (!contract.friend) {
						let li = makeli(symbol, contract);
						let prem = 0;
						if (data.callExpDateMap[dateMap(contract.expire)]) {
							if (!(data.callExpDateMap[dateMap(contract.expire)][strikeMap(contract.strike)])) prem = -1;
							prem = data.callExpDateMap[dateMap(contract.expire)][strikeMap(contract.strike)][0].bid;
						}
						let col = addCol(prem.toFixed(2), "75px", li);
						if (prem > 0) col.style.backgroundColor = "#dff";
						D('singles').appendChild(li);
						
						createSingleOrder(li, contract, prem + parseFloat(contract.tick));
					}
				});
				
				let bestPut = null;
				let ncPut = null;
				optionsBySymbol[symbol].shortPut.forEach(function(contract) {
				let tdastrikes = data.putExpDateMap[dateMap(contract.expire)];
				if (tdastrikes && tdastrikes[strikeMap(contract.strike)]) {
					contract.premium = tdastrikes[strikeMap(contract.strike)][0].ask;
					let expirationM = tdastrikes[strikeMap(contract.strike)][0].expirationDate;
					contract.rate = 100*100*contract.premium*365*1000*60*60*24/(contract.closeRelease*(1000*60*60*66 + expirationM-Date.now()));
					if ((!bestPut && contract.closeRelease > 0) || (bestPut && contract.rate < bestPut.rate)) bestPut = contract;

					contract.ncRate = 100*100*contract.premium*365*1000*60*60*24/(contract.ncRelease*(1000*60*60*66 + expirationM-Date.now()));
					if ((!ncPut && contract.ncRelease > 0) || (ncPut && contract.ncRate < ncPut.ncRate)) ncPut = contract;
				}
				});

				let bestCondor = {call:null, put:null, rate:Infinity};
				let bestCall = null;
				let ncCall = null;
				optionsBySymbol[symbol].shortCall.forEach(function(contract) {
				let tdastrikes = data.callExpDateMap[dateMap(contract.expire)];
				if (tdastrikes && tdastrikes[strikeMap(contract.strike)]) {
					contract.premium = tdastrikes[strikeMap(contract.strike)][0].ask;
					let expirationM = tdastrikes[strikeMap(contract.strike)][0].expirationDate;
					contract.rate = 100*100*contract.premium*365*1000*60*60*24/(contract.closeRelease*(1000*60*60*66 + expirationM-Date.now()));
					if ((!bestCall && contract.closeRelease > 0) || (bestCall && contract.rate < bestCall.rate)) bestCall = contract;

					contract.ncRate = 100*100*contract.premium*365*1000*60*60*24/(contract.ncRelease*(1000*60*60*66 + expirationM-Date.now()));
					if ((!ncCall && contract.ncRelease > 0) || (ncCall && contract.ncRate < ncCall.ncRate)) ncCall = contract;

					contract.condorPair.forEach(function(pair) {
						let contract2 = pair.condorPair;
						contract2.premium = data.putExpDateMap[dateMap(contract.expire)][strikeMap(contract2.strike)][0].ask;
						let condorRate = 100*100*(contract2.premium + contract.premium)*365*1000*60*60*24/(pair.condorRelease*(1000*60*60*66 + expirationM-Date.now()));
						if (condorRate < bestCondor.rate) 
							bestCondor = {call:contract, put:contract2, premium:(contract2.premium + contract.premium), rate:condorRate, release:pair.condorRelease};
					});
				}
				});

				function addColCost(li, elt, rate, collateral) {
					li.title = rate;
					let col = addCol(elt.premium.toFixed(2), "75px", li);
					col.style.backgroundColor = "#dff";
					col = addCol("$" + collateral, "75px", li);
					col.style.backgroundColor = "#dff";
					col = addCol(Math.round(rate) + "%", "75px", li);
					col.style.backgroundColor = "#dff";
				}

				
				function createOrder(li, contract, orderPrem) {
				li.firstChild.style.cursor = "pointer";	
				li.firstChild.style.backgroundColor = "#ddf";	
				li.firstChild.onclick = function() {
				if (confirm("Proceed to buy this spread for collateral?")) {
					if (orderPrem <= 0) orderPrem = parseFloat(contract.tick);
					let json = {
						'account': accountURL,
						'direction': 'debit',
						'time_in_force': 'gfd',
						'legs': [{'position_effect': 'close', 'side': 'buy', 'ratio_quantity': 1, 'option': contract.url }],
						'type': 'limit',
						'trigger': 'immediate',
						'price': orderPrem,
						'quantity': 1,
						'override_day_trade_checks': false,
						'override_dtbp_checks': false,
						'ref_id': generate_device_token()
					}
					console.log(json);
					fetchData('https://api.robinhood.com/options/orders/', 'POST', { headers:authHeader, json:json }).then(function(data) {
						console.log("The response to the order: ");
						console.log(data);

						let orderli = makeli(symbol, contract);
						// orderli.style.marginBottom = "10px";
						if (data.detail) addCol(data.detail, "calc(100% - 350px)", orderli);
						else {
							li.style.color = "#aaa";
							li.firstChild.style.backgroundColor = "";
							li.firstChild.style.pointerEvents = "none";
							
							let col = addCol(json.legs[0].side, "75px", orderli);
							col.style.backgroundColor = "#dff";
							col = addCol(json.legs[0].position_effect, "75px", orderli);
							col.style.backgroundColor = "#dff";
							col = addCol(orderPrem.toFixed(2), "75px", orderli);
							col.style.backgroundColor = "#dff";
							let processedCol = addCol(parseFloat(data.processed_quantity), "75px", orderli);
							let msg = addCol("Pending...", "calc(100% - 650px)", orderli);

							
							function orderStatus(data) {
								if (parseFloat(data.processed_quantity) > 0) {
									processedCol.textContent = "$" + parseFloat(data.processed_premium).toFixed(2);
									msg.textContent = "Partially completed...";
								}								
								if (Math.round(parseFloat(data.pending_quantity)) == 0) {
									msg.textContent = "Completed!";
									msg.style.pointerEvents = "none";
									msg.style.backgroundColor = "";	
								}
							}
							orderStatus(data);
							
							orderli.onclick = function() {
								fetchData('https://api.robinhood.com/options/orders/' + data.id, 'GET', { headers:authHeader }).then(function(data) {
									console.log("Checking for update on status for order:");
									console.log(data);
									orderStatus(data);
								});
							}

							msg.style.cursor = "pointer";
							msg.style.backgroundColor = "#ddf";	
							msg.onclick = function() {										
							if (confirm("Cancel buying this spread for collateral?")) {
								fetchData(data.cancel_url, 'POST', { headers:authHeader }).then(function(data) {
									console.log("The response to the cancel request: ");
									console.log(data);
									if (data.detail) msg.textContent = data.detail;
									else {
										processedCol.textContent = 'X';
										msg.textContent = "Cancelled!";
										msg.style.pointerEvents = "none";
										msg.style.backgroundColor = "";
										li.style.color = "";
										li.firstChild.style.backgroundColor = "#ddf";
										li.firstChild.style.pointerEvents = "";
										createOrder(orderli, contract, orderPrem + parseFloat(contract.tick));
									}
								});
							}
							}
						}
						D('orders').appendChild(orderli);
					});
				}
				}
				}

				if (ncPut) {						
					let li = makeli(symbol, ncPut);
					addColCost(li, ncPut, ncPut.ncRate, ncPut.ncRelease);
					addOrdered(li, D('ncRelease'));
					createOrder(li, ncPut, ncPut.premium - parseFloat(ncPut.tick));
				}
				if (bestPut) {						
					let li = makeli(symbol, bestPut);
					addColCost(li, bestPut, bestPut.rate, bestPut.closeRelease);
					addOrdered(li, D('release'));
					createOrder(li, bestPut, bestPut.premium - parseFloat(bestPut.tick));
				}
				if (ncCall) {					
					let li = makeli(symbol, ncCall);
					addColCost(li, ncCall, ncCall.ncRate, ncCall.ncRelease);
					addOrdered(li, D('ncRelease'));
					createOrder(li, ncCall, ncCall.premium - parseFloat(ncCall.tick));
				}
				if (bestCall) {					
					let li = makeli(symbol, bestCall);
					addColCost(li, bestCall, bestCall.rate, bestCall.closeRelease);
					addOrdered(li, D('release'));
					createOrder(li, bestCall, bestCall.premium - parseFloat(bestCall.tick));
				}
				if (bestCondor.release) {
					let li = makeli(symbol, bestCondor.call);

					addCol(bestCondor.put.type, "50px", li);
					addCol("$" + bestCondor.put.strike/100, "75px", li);

					addColCost(li, bestCondor, bestCondor.rate, bestCondor.release);					
					addOrdered(li, D('condorRelease'));
				}
			} 			       	       
			});
		});
	}
	
	Promise.all(promises).then(function() {
		D('optionButton').disabled = false;
		fetchData('https://query1.finance.yahoo.com/v7/finance/quote?symbols=' + queryString, 'GET').then(function(data) {
		for (let i = 0; i < data.quoteResponse.result.length; i++) {
			optionsBySymbol[data.quoteResponse.result[i].symbol].shortPut.forEach(function(contract) {
				if (contract.strike > 100*0.97*data.quoteResponse.result[i].regularMarketPrice) {
					let li = makeli(data.quoteResponse.result[i].symbol, contract);
					D('itm').appendChild(li);
				}
			});
			optionsBySymbol[data.quoteResponse.result[i].symbol].shortCall.forEach(function(contract) {
				if (contract.strike < 100*1.03*data.quoteResponse.result[i].regularMarketPrice) {
					let li = makeli(data.quoteResponse.result[i].symbol, contract);
					D('itm').appendChild(li);
				}
			});
		}
		});
	});
});
}	
	
function findCallPair(symbol, defCall, shortCall) {	
	let data = optionsBySymbol[symbol];
	let collateral = Infinity;
	let candidate = null;
	let seeker = defCall;
	if (!seeker) seeker = shortCall;
	if (defCall) {
		for (let j = 0; j < data.shortCall.length; j++) {
			evaluate(defCall, data.shortCall[j], data.shortCall[j]);
		}
	}
	if (shortCall) {
		for (let j = 0; j < data.defCall.length; j++) {
			evaluate(data.defCall[j], shortCall, data.defCall[j]);
		}
	}
	
	function evaluate(defCall, shortCall, subject) {
		if (defCall.expire >= shortCall.expire && callCollateral(defCall, shortCall) < collateral 
		    && (callCollateral(defCall, shortCall) < subject.collateral || (callCollateral(defCall, shortCall) == subject.collateral && 
										    (seeker.strike > subject.friend.strike || seeker.expire < subject.friend.expire)))) {
			collateral = callCollateral(defCall, shortCall);
			candidate = subject;
		}
	}
	
	if (candidate) {
		let orphan = candidate.friend;
		if (orphan) clearOption(orphan);
		
		candidate.friend = seeker;
		seeker.friend = candidate;
		candidate.collateral = collateral;
		seeker.collateral = collateral;

		if (orphan) {
			if (defCall) findCallPair(symbol, orphan);
			else if (shortCall) findCallPair(symbol, null, orphan);
		}
	}	

	function callCollateral(defCall, shortCall) {	
		if (defCall.strike > shortCall.strike) return defCall.strike - shortCall.strike;
		return 0;
	}
}
	
function clearOption(option) {
	delete option.friend;
	delete option.release;
	delete option.collateral;
}
	
function findPutPair(symbol, defPut, shortPut) {	
	let data = optionsBySymbol[symbol];
	let release = 0;
	let candidate = null;
	let seeker = defPut;
	if (!seeker) seeker = shortPut;
	if (defPut) {
		for (let j = 0; j < data.shortPut.length; j++) {
			evaluate(defPut, data.shortPut[j], data.shortPut[j]);
		}
	}
	if (shortPut) {
		for (let j = 0; j < data.defPut.length; j++) {
			evaluate(data.defPut[j], shortPut, data.defPut[j]);
		}
	}
	
	function evaluate(defPut, shortPut, subject) {
		if (defPut.expire >= shortPut.expire && putGain(defPut, shortPut) > release 
		    && (putGain(defPut, shortPut) > subject.release || (putGain(defPut, shortPut) == subject.release && 
									(seeker.strike < subject.friend.strike || seeker.expire < subject.friend.expire)) )) {
			release = putGain(defPut, shortPut);
			candidate = subject;
		}
	}

	function putGain(defPut, shortPut) {
		let release = shortPut.strike;
		if (defPut.strike < shortPut.strike) release = defPut.strike;
		return release;
	}

	if (candidate) {
		let orphan = candidate.friend;
		if (orphan) clearOption(orphan);
		
		candidate.friend = seeker;
		seeker.friend = candidate;
		candidate.release = release;
		seeker.release = release;
		
		candidate.collateral = candidate.strike - candidate.release;
		seeker.collateral = seeker.strike - seeker.release;
		
		if (orphan) {
			if (defPut) findPutPair(symbol, orphan);
			else if (shortPut) findPutPair(symbol, null, orphan);
		}
	}	
}
	
function noCondorCalls(symbol) {
	let data = optionsBySymbol[symbol];
	let totalCalls = 0;
	data.shortCall.forEach(function(contract) {
		if (contract.collateral !== undefined) totalCalls += contract.collateral;
		else console.log("CALL CONTRACT LACKS COLLATERAL");
	});	
	return totalCalls;
}
	
function noCondorPuts(symbol) {
	let data = optionsBySymbol[symbol];
	let totalPuts = 0;	
	data.shortPut.forEach(function(contract) {
		if (contract.collateral) totalPuts += contract.collateral;
		else totalPuts += contract.strike;
	});	
	return totalPuts;
}

function condor(symbol, build) {
	let data = optionsBySymbol[symbol];
	let callExpireTypes = {};
	let putExpireTypes = {};
	data.shortCall.forEach(function(contract) {
		if (!callExpireTypes[contract.expire]) {
					callExpireTypes[contract.expire] = {};
					putExpireTypes[contract.expire] = {};
		}
		if (contract.collateral !== undefined) {
			if (!callExpireTypes[contract.expire][contract.strike]) callExpireTypes[contract.expire][contract.strike] = contract.collateral;
			else callExpireTypes[contract.expire][contract.strike] += contract.collateral;
		} else console.log("CALL CONTRACT LACKS COLLATERAL");
	});
	
	data.shortPut.forEach(function(contract) {
		if (!putExpireTypes[contract.expire]) putExpireTypes[contract.expire] = {};
		if (contract.collateral) {
			if (!putExpireTypes[contract.expire][contract.strike]) putExpireTypes[contract.expire][contract.strike] = contract.collateral;
			else putExpireTypes[contract.expire][contract.strike] += contract.collateral;
		}
		else {
			if (!putExpireTypes[contract.expire][contract.strike]) putExpireTypes[contract.expire][contract.strike] = contract.strike;
			else putExpireTypes[contract.expire][contract.strike] += contract.strike;
		}
	});	
	
	let totalSaved = 0;
	for (let expiration in putExpireTypes) {
		for (let strike in putExpireTypes[expiration]) {
			for (let callStrike in callExpireTypes[expiration]) {
				if (parseInt(callStrike) > parseInt(strike)) {
					if (callExpireTypes[expiration][callStrike] <= putExpireTypes[expiration][strike]) {
						putExpireTypes[expiration][strike] -= callExpireTypes[expiration][callStrike];						
						totalSaved += callExpireTypes[expiration][callStrike];
						callExpireTypes[expiration][callStrike] = 0;
					}
					else {
						callExpireTypes[expiration][callStrike] -= putExpireTypes[expiration][strike];
						totalSaved += putExpireTypes[expiration][strike];
						putExpireTypes[expiration][strike] = 0;
						break;
					}
				}
			}
		}
	}
	
	let totalPuts = 0;
	let totalCalls = 0;
	for (let expiration in putExpireTypes) {
		let expirePuts = 0;
		for (let strike in putExpireTypes[expiration]) {
			expirePuts += putExpireTypes[expiration][strike];
		}
		
		if (build && expirePuts > 0) {
			let li = makeli(symbol);
			li.title = 0 - expirePuts;	
			addCol(expiration, "125px", li);
			addCol("call", "50px", li);
			addCol("$" + expirePuts, "100px", li);
			addOrdered(li, D('unpaired'));
		}
		totalPuts += expirePuts;
		
		let expireCalls = 0;
		for (let callStrike in callExpireTypes[expiration]) {
			expireCalls += callExpireTypes[expiration][callStrike];
		}
		
		if (build && expireCalls > 0) {
			let li = makeli(symbol);
			li.title = 0 - expireCalls;
			addCol(expiration, "125px", li);
			addCol("put", "50px", li);
			addCol("$" + expireCalls, "100px", li);
			addOrdered(li, D('unpaired'));
		}
		totalCalls += expireCalls;
	}
					
	return totalSaved + totalPuts + totalCalls;
}
	

</script>
